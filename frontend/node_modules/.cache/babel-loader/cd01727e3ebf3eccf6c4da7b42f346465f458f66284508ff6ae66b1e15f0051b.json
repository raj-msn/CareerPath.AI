{"ast":null,"code":"import { l as log, m as evaluate, c as getConfig, M as decodeEntities, d as sanitizeText, u as utils } from \"./mermaid-b5860b54.js\";\nimport { select, line, curveBasis } from \"d3\";\nimport { a as createText } from \"./createText-2e5e7dd3.js\";\nconst insertMarkers = (elem, markerArray, type, id) => {\n  markerArray.forEach(markerName => {\n    markers[markerName](elem, type, id);\n  });\n};\nconst extension = (elem, type, id) => {\n  log.trace(\"Making markers for \", id);\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-extensionStart\").attr(\"class\", \"marker extension \" + type).attr(\"refX\", 18).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,7 L18,13 V 1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-extensionEnd\").attr(\"class\", \"marker extension \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,1 V 13 L18,7 Z\");\n};\nconst composition = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-compositionStart\").attr(\"class\", \"marker composition \" + type).attr(\"refX\", 18).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-compositionEnd\").attr(\"class\", \"marker composition \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n};\nconst aggregation = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-aggregationStart\").attr(\"class\", \"marker aggregation \" + type).attr(\"refX\", 18).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-aggregationEnd\").attr(\"class\", \"marker aggregation \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n};\nconst dependency = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-dependencyStart\").attr(\"class\", \"marker dependency \" + type).attr(\"refX\", 6).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 5,7 L9,13 L1,7 L9,1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-dependencyEnd\").attr(\"class\", \"marker dependency \" + type).attr(\"refX\", 13).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L14,7 L9,1 Z\");\n};\nconst lollipop = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-lollipopStart\").attr(\"class\", \"marker lollipop \" + type).attr(\"refX\", 13).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"circle\").attr(\"stroke\", \"black\").attr(\"fill\", \"transparent\").attr(\"cx\", 7).attr(\"cy\", 7).attr(\"r\", 6);\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-lollipopEnd\").attr(\"class\", \"marker lollipop \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"circle\").attr(\"stroke\", \"black\").attr(\"fill\", \"transparent\").attr(\"cx\", 7).attr(\"cy\", 7).attr(\"r\", 6);\n};\nconst point = (elem, type, id) => {\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-pointEnd\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 6).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 12).attr(\"markerHeight\", 12).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-pointStart\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 4.5).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 12).attr(\"markerHeight\", 12).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 0 5 L 10 10 L 10 0 z\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n};\nconst circle$1 = (elem, type, id) => {\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-circleEnd\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 11).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"circle\").attr(\"cx\", \"5\").attr(\"cy\", \"5\").attr(\"r\", \"5\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-circleStart\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", -1).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"circle\").attr(\"cx\", \"5\").attr(\"cy\", \"5\").attr(\"r\", \"5\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n};\nconst cross = (elem, type, id) => {\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-crossEnd\").attr(\"class\", \"marker cross \" + type).attr(\"viewBox\", \"0 0 11 11\").attr(\"refX\", 12).attr(\"refY\", 5.2).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,1 l 9,9 M 10,1 l -9,9\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 2).style(\"stroke-dasharray\", \"1,0\");\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-crossStart\").attr(\"class\", \"marker cross \" + type).attr(\"viewBox\", \"0 0 11 11\").attr(\"refX\", -1).attr(\"refY\", 5.2).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,1 l 9,9 M 10,1 l -9,9\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 2).style(\"stroke-dasharray\", \"1,0\");\n};\nconst barb = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-barbEnd\").attr(\"refX\", 19).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 14).attr(\"markerUnits\", \"strokeWidth\").attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 19,7 L9,13 L14,7 L9,1 Z\");\n};\nconst markers = {\n  extension,\n  composition,\n  aggregation,\n  dependency,\n  lollipop,\n  point,\n  circle: circle$1,\n  cross,\n  barb\n};\nconst insertMarkers$1 = insertMarkers;\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlLabel(node) {\n  const fo = select(document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\"));\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html('<span class=\"' + labelClass + '\" ' + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\");\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"inline-block\");\n  div.style(\"white-space\", \"nowrap\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  return fo.node();\n}\nconst createLabel = (_vertexText, style, isTitle, isNode) => {\n  let vertexText = _vertexText || \"\";\n  if (typeof vertexText === \"object\") {\n    vertexText = vertexText[0];\n  }\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    vertexText = vertexText.replace(/\\\\n|\\n/g, \"<br />\");\n    log.debug(\"vertexText\" + vertexText);\n    const node = {\n      isNode,\n      label: decodeEntities(vertexText).replace(/fa[blrs]?:fa-[\\w-]+/g,\n      // cspell: disable-line\n      s => `<i class='${s.replace(\":\", \" \")}'></i>`),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    let vertexNode = addHtmlLabel(node);\n    return vertexNode;\n  } else {\n    const svgLabel = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    svgLabel.setAttribute(\"style\", style.replace(\"color:\", \"fill:\"));\n    let rows = [];\n    if (typeof vertexText === \"string\") {\n      rows = vertexText.split(/\\\\n|\\n|<br\\s*\\/?>/gi);\n    } else if (Array.isArray(vertexText)) {\n      rows = vertexText;\n    } else {\n      rows = [];\n    }\n    for (const row of rows) {\n      const tspan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n      tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n      tspan.setAttribute(\"dy\", \"1em\");\n      tspan.setAttribute(\"x\", \"0\");\n      if (isTitle) {\n        tspan.setAttribute(\"class\", \"title-row\");\n      } else {\n        tspan.setAttribute(\"class\", \"row\");\n      }\n      tspan.textContent = row.trim();\n      svgLabel.appendChild(tspan);\n    }\n    return svgLabel;\n  }\n};\nconst createLabel$1 = createLabel;\nconst labelHelper = async (parent, node, _classes, isNode) => {\n  let classes;\n  const useHtmlLabels = node.useHtmlLabels || evaluate(getConfig().flowchart.htmlLabels);\n  if (!_classes) {\n    classes = \"node default\";\n  } else {\n    classes = _classes;\n  }\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", classes).attr(\"id\", node.domId || node.id);\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"label\").attr(\"style\", node.labelStyle);\n  let labelText;\n  if (node.labelText === void 0) {\n    labelText = \"\";\n  } else {\n    labelText = typeof node.labelText === \"string\" ? node.labelText : node.labelText[0];\n  }\n  const textNode = label.node();\n  let text;\n  if (node.labelType === \"markdown\") {\n    text = createText(label, sanitizeText(decodeEntities(labelText), getConfig()), {\n      useHtmlLabels,\n      width: node.width || getConfig().flowchart.wrappingWidth,\n      classes: \"markdown-node-label\"\n    });\n  } else {\n    text = textNode.appendChild(createLabel$1(sanitizeText(decodeEntities(labelText), getConfig()), node.labelStyle, false, isNode));\n  }\n  let bbox = text.getBBox();\n  const halfPadding = node.padding / 2;\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    const images = div.getElementsByTagName(\"img\");\n    if (images) {\n      const noImgText = labelText.replace(/<img[^>]*>/g, \"\").trim() === \"\";\n      await Promise.all([...images].map(img => new Promise(res => {\n        function setupImage() {\n          img.style.display = \"flex\";\n          img.style.flexDirection = \"column\";\n          if (noImgText) {\n            const bodyFontSize = getConfig().fontSize ? getConfig().fontSize : window.getComputedStyle(document.body).fontSize;\n            const enlargingFactor = 5;\n            const width = parseInt(bodyFontSize, 10) * enlargingFactor + \"px\";\n            img.style.minWidth = width;\n            img.style.maxWidth = width;\n          } else {\n            img.style.width = \"100%\";\n          }\n          res(img);\n        }\n        setTimeout(() => {\n          if (img.complete) {\n            setupImage();\n          }\n        });\n        img.addEventListener(\"error\", setupImage);\n        img.addEventListener(\"load\", setupImage);\n      })));\n    }\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  if (useHtmlLabels) {\n    label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + -bbox.height / 2 + \")\");\n  } else {\n    label.attr(\"transform\", \"translate(0, \" + -bbox.height / 2 + \")\");\n  }\n  if (node.centerLabel) {\n    label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + -bbox.height / 2 + \")\");\n  }\n  label.insert(\"rect\", \":first-child\");\n  return {\n    shapeSvg,\n    bbox,\n    halfPadding,\n    label\n  };\n};\nconst updateNodeBounds = (node, element) => {\n  const bbox = element.node().getBBox();\n  node.width = bbox.width;\n  node.height = bbox.height;\n};\nfunction insertPolygonShape(parent, w, h, points) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\"points\", points.map(function (d) {\n    return d.x + \",\" + d.y;\n  }).join(\" \")).attr(\"class\", \"label-container\").attr(\"transform\", \"translate(\" + -w / 2 + \",\" + h / 2 + \")\");\n}\nfunction intersectNode(node, point2) {\n  return node.intersect(point2);\n}\nfunction intersectEllipse(node, rx, ry, point2) {\n  var cx = node.x;\n  var cy = node.y;\n  var px = cx - point2.x;\n  var py = cy - point2.y;\n  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);\n  var dx = Math.abs(rx * ry * px / det);\n  if (point2.x < cx) {\n    dx = -dx;\n  }\n  var dy = Math.abs(rx * ry * py / det);\n  if (point2.y < cy) {\n    dy = -dy;\n  }\n  return {\n    x: cx + dx,\n    y: cy + dy\n  };\n}\nfunction intersectCircle(node, rx, point2) {\n  return intersectEllipse(node, rx, rx, point2);\n}\nfunction intersectLine(p1, p2, q1, q2) {\n  var a1, a2, b1, b2, c1, c2;\n  var r1, r2, r3, r4;\n  var denom, offset, num;\n  var x, y;\n  a1 = p2.y - p1.y;\n  b1 = p1.x - p2.x;\n  c1 = p2.x * p1.y - p1.x * p2.y;\n  r3 = a1 * q1.x + b1 * q1.y + c1;\n  r4 = a1 * q2.x + b1 * q2.y + c1;\n  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {\n    return;\n  }\n  a2 = q2.y - q1.y;\n  b2 = q1.x - q2.x;\n  c2 = q2.x * q1.y - q1.x * q2.y;\n  r1 = a2 * p1.x + b2 * p1.y + c2;\n  r2 = a2 * p2.x + b2 * p2.y + c2;\n  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {\n    return;\n  }\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return;\n  }\n  offset = Math.abs(denom / 2);\n  num = b1 * c2 - b2 * c1;\n  x = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  num = a2 * c1 - a1 * c2;\n  y = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  return {\n    x,\n    y\n  };\n}\nfunction sameSign(r1, r2) {\n  return r1 * r2 > 0;\n}\nfunction intersectPolygon(node, polyPoints, point2) {\n  var x1 = node.x;\n  var y1 = node.y;\n  var intersections = [];\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  if (typeof polyPoints.forEach === \"function\") {\n    polyPoints.forEach(function (entry) {\n      minX = Math.min(minX, entry.x);\n      minY = Math.min(minY, entry.y);\n    });\n  } else {\n    minX = Math.min(minX, polyPoints.x);\n    minY = Math.min(minY, polyPoints.y);\n  }\n  var left = x1 - node.width / 2 - minX;\n  var top = y1 - node.height / 2 - minY;\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect2 = intersectLine(node, point2, {\n      x: left + p1.x,\n      y: top + p1.y\n    }, {\n      x: left + p2.x,\n      y: top + p2.y\n    });\n    if (intersect2) {\n      intersections.push(intersect2);\n    }\n  }\n  if (!intersections.length) {\n    return node;\n  }\n  if (intersections.length > 1) {\n    intersections.sort(function (p, q) {\n      var pdx = p.x - point2.x;\n      var pdy = p.y - point2.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n      var qdx = q.x - point2.x;\n      var qdy = q.y - point2.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n      return distp < distq ? -1 : distp === distq ? 0 : 1;\n    });\n  }\n  return intersections[0];\n}\nconst intersectRect = (node, point2) => {\n  var x = node.x;\n  var y = node.y;\n  var dx = point2.x - x;\n  var dy = point2.y - y;\n  var w = node.width / 2;\n  var h = node.height / 2;\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = dy === 0 ? 0 : h * dx / dy;\n    sy = h;\n  } else {\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = dx === 0 ? 0 : w * dy / dx;\n  }\n  return {\n    x: x + sx,\n    y: y + sy\n  };\n};\nconst intersectRect$1 = intersectRect;\nconst intersect = {\n  node: intersectNode,\n  circle: intersectCircle,\n  ellipse: intersectEllipse,\n  polygon: intersectPolygon,\n  rect: intersectRect$1\n};\nconst note = async (parent, node) => {\n  const useHtmlLabels = node.useHtmlLabels || getConfig().flowchart.htmlLabels;\n  if (!useHtmlLabels) {\n    node.centerLabel = true;\n  }\n  const {\n    shapeSvg,\n    bbox,\n    halfPadding\n  } = await labelHelper(parent, node, \"node \" + node.classes, true);\n  log.info(\"Classes = \", node.classes);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  rect2.attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", -bbox.width / 2 - halfPadding).attr(\"y\", -bbox.height / 2 - halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst note$1 = note;\nconst expandAndDeduplicateDirections = directions => {\n  const uniqueDirections = /* @__PURE__ */new Set();\n  for (const direction of directions) {\n    switch (direction) {\n      case \"x\":\n        uniqueDirections.add(\"right\");\n        uniqueDirections.add(\"left\");\n        break;\n      case \"y\":\n        uniqueDirections.add(\"up\");\n        uniqueDirections.add(\"down\");\n        break;\n      default:\n        uniqueDirections.add(direction);\n        break;\n    }\n  }\n  return uniqueDirections;\n};\nconst getArrowPoints = (duplicatedDirections, bbox, node) => {\n  const directions = expandAndDeduplicateDirections(duplicatedDirections);\n  const f = 2;\n  const height = bbox.height + 2 * node.padding;\n  const midpoint = height / f;\n  const width = bbox.width + 2 * midpoint + node.padding;\n  const padding = node.padding / 2;\n  if (directions.has(\"right\") && directions.has(\"left\") && directions.has(\"up\") && directions.has(\"down\")) {\n    return [\n    // Bottom\n    {\n      x: 0,\n      y: 0\n    }, {\n      x: midpoint,\n      y: 0\n    }, {\n      x: width / 2,\n      y: 2 * padding\n    }, {\n      x: width - midpoint,\n      y: 0\n    }, {\n      x: width,\n      y: 0\n    },\n    // Right\n    {\n      x: width,\n      y: -height / 3\n    }, {\n      x: width + 2 * padding,\n      y: -height / 2\n    }, {\n      x: width,\n      y: -2 * height / 3\n    }, {\n      x: width,\n      y: -height\n    },\n    // Top\n    {\n      x: width - midpoint,\n      y: -height\n    }, {\n      x: width / 2,\n      y: -height - 2 * padding\n    }, {\n      x: midpoint,\n      y: -height\n    },\n    // Left\n    {\n      x: 0,\n      y: -height\n    }, {\n      x: 0,\n      y: -2 * height / 3\n    }, {\n      x: -2 * padding,\n      y: -height / 2\n    }, {\n      x: 0,\n      y: -height / 3\n    }];\n  }\n  if (directions.has(\"right\") && directions.has(\"left\") && directions.has(\"up\")) {\n    return [{\n      x: midpoint,\n      y: 0\n    }, {\n      x: width - midpoint,\n      y: 0\n    }, {\n      x: width,\n      y: -height / 2\n    }, {\n      x: width - midpoint,\n      y: -height\n    }, {\n      x: midpoint,\n      y: -height\n    }, {\n      x: 0,\n      y: -height / 2\n    }];\n  }\n  if (directions.has(\"right\") && directions.has(\"left\") && directions.has(\"down\")) {\n    return [{\n      x: 0,\n      y: 0\n    }, {\n      x: midpoint,\n      y: -height\n    }, {\n      x: width - midpoint,\n      y: -height\n    }, {\n      x: width,\n      y: 0\n    }];\n  }\n  if (directions.has(\"right\") && directions.has(\"up\") && directions.has(\"down\")) {\n    return [{\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: -midpoint\n    }, {\n      x: width,\n      y: -height + midpoint\n    }, {\n      x: 0,\n      y: -height\n    }];\n  }\n  if (directions.has(\"left\") && directions.has(\"up\") && directions.has(\"down\")) {\n    return [{\n      x: width,\n      y: 0\n    }, {\n      x: 0,\n      y: -midpoint\n    }, {\n      x: 0,\n      y: -height + midpoint\n    }, {\n      x: width,\n      y: -height\n    }];\n  }\n  if (directions.has(\"right\") && directions.has(\"left\")) {\n    return [{\n      x: midpoint,\n      y: 0\n    }, {\n      x: midpoint,\n      y: -padding\n    }, {\n      x: width - midpoint,\n      y: -padding\n    }, {\n      x: width - midpoint,\n      y: 0\n    }, {\n      x: width,\n      y: -height / 2\n    }, {\n      x: width - midpoint,\n      y: -height\n    }, {\n      x: width - midpoint,\n      y: -height + padding\n    }, {\n      x: midpoint,\n      y: -height + padding\n    }, {\n      x: midpoint,\n      y: -height\n    }, {\n      x: 0,\n      y: -height / 2\n    }];\n  }\n  if (directions.has(\"up\") && directions.has(\"down\")) {\n    return [\n    // Bottom center\n    {\n      x: width / 2,\n      y: 0\n    },\n    // Left pont of bottom arrow\n    {\n      x: 0,\n      y: -padding\n    }, {\n      x: midpoint,\n      y: -padding\n    },\n    // Left top over vertical section\n    {\n      x: midpoint,\n      y: -height + padding\n    }, {\n      x: 0,\n      y: -height + padding\n    },\n    // Top of arrow\n    {\n      x: width / 2,\n      y: -height\n    }, {\n      x: width,\n      y: -height + padding\n    },\n    // Top of right vertical bar\n    {\n      x: width - midpoint,\n      y: -height + padding\n    }, {\n      x: width - midpoint,\n      y: -padding\n    }, {\n      x: width,\n      y: -padding\n    }];\n  }\n  if (directions.has(\"right\") && directions.has(\"up\")) {\n    return [{\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: -midpoint\n    }, {\n      x: 0,\n      y: -height\n    }];\n  }\n  if (directions.has(\"right\") && directions.has(\"down\")) {\n    return [{\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: 0\n    }, {\n      x: 0,\n      y: -height\n    }];\n  }\n  if (directions.has(\"left\") && directions.has(\"up\")) {\n    return [{\n      x: width,\n      y: 0\n    }, {\n      x: 0,\n      y: -midpoint\n    }, {\n      x: width,\n      y: -height\n    }];\n  }\n  if (directions.has(\"left\") && directions.has(\"down\")) {\n    return [{\n      x: width,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: -height\n    }];\n  }\n  if (directions.has(\"right\")) {\n    return [{\n      x: midpoint,\n      y: -padding\n    }, {\n      x: midpoint,\n      y: -padding\n    }, {\n      x: width - midpoint,\n      y: -padding\n    }, {\n      x: width - midpoint,\n      y: 0\n    }, {\n      x: width,\n      y: -height / 2\n    }, {\n      x: width - midpoint,\n      y: -height\n    }, {\n      x: width - midpoint,\n      y: -height + padding\n    },\n    // top left corner of arrow\n    {\n      x: midpoint,\n      y: -height + padding\n    }, {\n      x: midpoint,\n      y: -height + padding\n    }];\n  }\n  if (directions.has(\"left\")) {\n    return [{\n      x: midpoint,\n      y: 0\n    }, {\n      x: midpoint,\n      y: -padding\n    },\n    // Two points, the right corners\n    {\n      x: width - midpoint,\n      y: -padding\n    }, {\n      x: width - midpoint,\n      y: -height + padding\n    }, {\n      x: midpoint,\n      y: -height + padding\n    }, {\n      x: midpoint,\n      y: -height\n    }, {\n      x: 0,\n      y: -height / 2\n    }];\n  }\n  if (directions.has(\"up\")) {\n    return [\n    // Bottom center\n    {\n      x: midpoint,\n      y: -padding\n    },\n    // Left top over vertical section\n    {\n      x: midpoint,\n      y: -height + padding\n    }, {\n      x: 0,\n      y: -height + padding\n    },\n    // Top of arrow\n    {\n      x: width / 2,\n      y: -height\n    }, {\n      x: width,\n      y: -height + padding\n    },\n    // Top of right vertical bar\n    {\n      x: width - midpoint,\n      y: -height + padding\n    }, {\n      x: width - midpoint,\n      y: -padding\n    }];\n  }\n  if (directions.has(\"down\")) {\n    return [\n    // Bottom center\n    {\n      x: width / 2,\n      y: 0\n    },\n    // Left pont of bottom arrow\n    {\n      x: 0,\n      y: -padding\n    }, {\n      x: midpoint,\n      y: -padding\n    },\n    // Left top over vertical section\n    {\n      x: midpoint,\n      y: -height + padding\n    }, {\n      x: width - midpoint,\n      y: -height + padding\n    }, {\n      x: width - midpoint,\n      y: -padding\n    }, {\n      x: width,\n      y: -padding\n    }];\n  }\n  return [{\n    x: 0,\n    y: 0\n  }];\n};\nconst formatClass = str => {\n  if (str) {\n    return \" \" + str;\n  }\n  return \"\";\n};\nconst getClassesFromNode = (node, otherClasses) => {\n  return `${otherClasses ? otherClasses : \"node default\"}${formatClass(node.classes)} ${formatClass(node.class)}`;\n};\nconst question = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const s = w + h;\n  const points = [{\n    x: s / 2,\n    y: 0\n  }, {\n    x: s,\n    y: -s / 2\n  }, {\n    x: s / 2,\n    y: -s\n  }, {\n    x: 0,\n    y: -s / 2\n  }];\n  log.info(\"Question main (Circle)\");\n  const questionElem = insertPolygonShape(shapeSvg, s, s, points);\n  questionElem.attr(\"style\", node.style);\n  updateNodeBounds(node, questionElem);\n  node.intersect = function (point2) {\n    log.warn(\"Intersect called\");\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst choice = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  const s = 28;\n  const points = [{\n    x: 0,\n    y: s / 2\n  }, {\n    x: s / 2,\n    y: 0\n  }, {\n    x: 0,\n    y: -s / 2\n  }, {\n    x: -s / 2,\n    y: 0\n  }];\n  const choice2 = shapeSvg.insert(\"polygon\", \":first-child\").attr(\"points\", points.map(function (d) {\n    return d.x + \",\" + d.y;\n  }).join(\" \"));\n  choice2.attr(\"class\", \"state-start\").attr(\"r\", 7).attr(\"width\", 28).attr(\"height\", 28);\n  node.width = 28;\n  node.height = 28;\n  node.intersect = function (point2) {\n    return intersect.circle(node, 14, point2);\n  };\n  return shapeSvg;\n};\nconst hexagon = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const f = 4;\n  const h = bbox.height + node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = [{\n    x: m,\n    y: 0\n  }, {\n    x: w - m,\n    y: 0\n  }, {\n    x: w,\n    y: -h / 2\n  }, {\n    x: w - m,\n    y: -h\n  }, {\n    x: m,\n    y: -h\n  }, {\n    x: 0,\n    y: -h / 2\n  }];\n  const hex = insertPolygonShape(shapeSvg, w, h, points);\n  hex.attr(\"style\", node.style);\n  updateNodeBounds(node, hex);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst block_arrow = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, void 0, true);\n  const f = 2;\n  const h = bbox.height + 2 * node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = getArrowPoints(node.directions, bbox, node);\n  const blockArrow = insertPolygonShape(shapeSvg, w, h, points);\n  blockArrow.attr(\"style\", node.style);\n  updateNodeBounds(node, blockArrow);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_left_inv_arrow = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: -h / 2,\n    y: 0\n  }, {\n    x: w,\n    y: 0\n  }, {\n    x: w,\n    y: -h\n  }, {\n    x: -h / 2,\n    y: -h\n  }, {\n    x: 0,\n    y: -h / 2\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  node.width = w + h;\n  node.height = h;\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_right = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: -2 * h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: -h\n  }, {\n    x: h / 6,\n    y: -h\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_left = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: 2 * h / 6,\n    y: 0\n  }, {\n    x: w + h / 6,\n    y: 0\n  }, {\n    x: w - 2 * h / 6,\n    y: -h\n  }, {\n    x: -h / 6,\n    y: -h\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst trapezoid = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: -2 * h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: -h\n  }, {\n    x: h / 6,\n    y: -h\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst inv_trapezoid = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: -h\n  }, {\n    x: -2 * h / 6,\n    y: -h\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_right_inv_arrow = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: 0,\n    y: 0\n  }, {\n    x: w + h / 2,\n    y: 0\n  }, {\n    x: w,\n    y: -h / 2\n  }, {\n    x: w + h / 2,\n    y: -h\n  }, {\n    x: 0,\n    y: -h\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst cylinder = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const rx = w / 2;\n  const ry = rx / (2.5 + w / 50);\n  const h = bbox.height + ry + node.padding;\n  const shape = \"M 0,\" + ry + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 a \" + rx + \",\" + ry + \" 0,0,0 \" + -w + \" 0 l 0,\" + h + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 l 0,\" + -h;\n  const el = shapeSvg.attr(\"label-offset-y\", ry).insert(\"path\", \":first-child\").attr(\"style\", node.style).attr(\"d\", shape).attr(\"transform\", \"translate(\" + -w / 2 + \",\" + -(h / 2 + ry) + \")\");\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    const pos = intersect.rect(node, point2);\n    const x = pos.x - node.x;\n    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {\n      let y = ry * ry * (1 - x * x / (rx * rx));\n      if (y != 0) {\n        y = Math.sqrt(y);\n      }\n      y = ry - y;\n      if (point2.y - node.y > 0) {\n        y = -y;\n      }\n      pos.y += y;\n    }\n    return pos;\n  };\n  return shapeSvg;\n};\nconst rect = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox,\n    halfPadding\n  } = await labelHelper(parent, node, \"node \" + node.classes + \" \" + node.class, true);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const totalWidth = node.positioned ? node.width : bbox.width + node.padding;\n  const totalHeight = node.positioned ? node.height : bbox.height + node.padding;\n  const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;\n  const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;\n  rect2.attr(\"class\", \"basic label-container\").attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", x).attr(\"y\", y).attr(\"width\", totalWidth).attr(\"height\", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete(\"borders\");\n    }\n    propKeys.forEach(propKey => {\n      log.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst composite = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox,\n    halfPadding\n  } = await labelHelper(parent, node, \"node \" + node.classes, true);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const totalWidth = node.positioned ? node.width : bbox.width + node.padding;\n  const totalHeight = node.positioned ? node.height : bbox.height + node.padding;\n  const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;\n  const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;\n  rect2.attr(\"class\", \"basic cluster composite label-container\").attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", x).attr(\"y\", y).attr(\"width\", totalWidth).attr(\"height\", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete(\"borders\");\n    }\n    propKeys.forEach(propKey => {\n      log.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst labelRect = async (parent, node) => {\n  const {\n    shapeSvg\n  } = await labelHelper(parent, node, \"label\", true);\n  log.trace(\"Classes = \", node.class);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const totalWidth = 0;\n  const totalHeight = 0;\n  rect2.attr(\"width\", totalWidth).attr(\"height\", totalHeight);\n  shapeSvg.attr(\"class\", \"label edgeLabel\");\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete(\"borders\");\n    }\n    propKeys.forEach(propKey => {\n      log.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nfunction applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {\n  const strokeDashArray = [];\n  const addBorder = length => {\n    strokeDashArray.push(length, 0);\n  };\n  const skipBorder = length => {\n    strokeDashArray.push(0, length);\n  };\n  if (borders.includes(\"t\")) {\n    log.debug(\"add top border\");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes(\"r\")) {\n    log.debug(\"add right border\");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  if (borders.includes(\"b\")) {\n    log.debug(\"add bottom border\");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes(\"l\")) {\n    log.debug(\"add left border\");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  rect2.attr(\"stroke-dasharray\", strokeDashArray.join(\" \"));\n}\nconst rectWithTitle = (parent, node) => {\n  let classes;\n  if (!node.classes) {\n    classes = \"node default\";\n  } else {\n    classes = \"node \" + node.classes;\n  }\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", classes).attr(\"id\", node.domId || node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const innerLine = shapeSvg.insert(\"line\");\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"label\");\n  const text2 = node.labelText.flat ? node.labelText.flat() : node.labelText;\n  let title = \"\";\n  if (typeof text2 === \"object\") {\n    title = text2[0];\n  } else {\n    title = text2;\n  }\n  log.info(\"Label text abc79\", title, text2, typeof text2 === \"object\");\n  const text = label.node().appendChild(createLabel$1(title, node.labelStyle, true, true));\n  let bbox = {\n    width: 0,\n    height: 0\n  };\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  log.info(\"Text 2\", text2);\n  const textRows = text2.slice(1, text2.length);\n  let titleBox = text.getBBox();\n  const descr = label.node().appendChild(createLabel$1(textRows.join ? textRows.join(\"<br/>\") : textRows, node.labelStyle, true, true));\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = descr.children[0];\n    const dv = select(descr);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  const halfPadding = node.padding / 2;\n  select(descr).attr(\"transform\", \"translate( \" + (\n  // (titleBox.width - bbox.width) / 2 +\n  bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + \", \" + (titleBox.height + halfPadding + 5) + \")\");\n  select(text).attr(\"transform\", \"translate( \" + (\n  // (titleBox.width - bbox.width) / 2 +\n  bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + \", 0)\");\n  bbox = label.node().getBBox();\n  label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + (-bbox.height / 2 - halfPadding + 3) + \")\");\n  rect2.attr(\"class\", \"outer title-state\").attr(\"x\", -bbox.width / 2 - halfPadding).attr(\"y\", -bbox.height / 2 - halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  innerLine.attr(\"class\", \"divider\").attr(\"x1\", -bbox.width / 2 - halfPadding).attr(\"x2\", bbox.width / 2 + halfPadding).attr(\"y1\", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr(\"y2\", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst stadium = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const h = bbox.height + node.padding;\n  const w = bbox.width + h / 4 + node.padding;\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\").attr(\"style\", node.style).attr(\"rx\", h / 2).attr(\"ry\", h / 2).attr(\"x\", -w / 2).attr(\"y\", -h / 2).attr(\"width\", w).attr(\"height\", h);\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst circle = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox,\n    halfPadding\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const circle2 = shapeSvg.insert(\"circle\", \":first-child\");\n  circle2.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"r\", bbox.width / 2 + halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  log.info(\"Circle main\");\n  updateNodeBounds(node, circle2);\n  node.intersect = function (point2) {\n    log.info(\"Circle intersect\", node, bbox.width / 2 + halfPadding, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding, point2);\n  };\n  return shapeSvg;\n};\nconst doublecircle = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox,\n    halfPadding\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const gap = 5;\n  const circleGroup = shapeSvg.insert(\"g\", \":first-child\");\n  const outerCircle = circleGroup.insert(\"circle\");\n  const innerCircle = circleGroup.insert(\"circle\");\n  circleGroup.attr(\"class\", node.class);\n  outerCircle.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"r\", bbox.width / 2 + halfPadding + gap).attr(\"width\", bbox.width + node.padding + gap * 2).attr(\"height\", bbox.height + node.padding + gap * 2);\n  innerCircle.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"r\", bbox.width / 2 + halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  log.info(\"DoubleCircle main\");\n  updateNodeBounds(node, outerCircle);\n  node.intersect = function (point2) {\n    log.info(\"DoubleCircle intersect\", node, bbox.width / 2 + halfPadding + gap, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding + gap, point2);\n  };\n  return shapeSvg;\n};\nconst subroutine = async (parent, node) => {\n  const {\n    shapeSvg,\n    bbox\n  } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [{\n    x: 0,\n    y: 0\n  }, {\n    x: w,\n    y: 0\n  }, {\n    x: w,\n    y: -h\n  }, {\n    x: 0,\n    y: -h\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: -8,\n    y: 0\n  }, {\n    x: w + 8,\n    y: 0\n  }, {\n    x: w + 8,\n    y: -h\n  }, {\n    x: -8,\n    y: -h\n  }, {\n    x: -8,\n    y: 0\n  }];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function (point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst start = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  const circle2 = shapeSvg.insert(\"circle\", \":first-child\");\n  circle2.attr(\"class\", \"state-start\").attr(\"r\", 7).attr(\"width\", 14).attr(\"height\", 14);\n  updateNodeBounds(node, circle2);\n  node.intersect = function (point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst forkJoin = (parent, node, dir) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  let width = 70;\n  let height = 10;\n  if (dir === \"LR\") {\n    width = 10;\n    height = 70;\n  }\n  const shape = shapeSvg.append(\"rect\").attr(\"x\", -1 * width / 2).attr(\"y\", -1 * height / 2).attr(\"width\", width).attr(\"height\", height).attr(\"class\", \"fork-join\");\n  updateNodeBounds(node, shape);\n  node.height = node.height + node.padding / 2;\n  node.width = node.width + node.padding / 2;\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst end = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  const innerCircle = shapeSvg.insert(\"circle\", \":first-child\");\n  const circle2 = shapeSvg.insert(\"circle\", \":first-child\");\n  circle2.attr(\"class\", \"state-start\").attr(\"r\", 7).attr(\"width\", 14).attr(\"height\", 14);\n  innerCircle.attr(\"class\", \"state-end\").attr(\"r\", 5).attr(\"width\", 10).attr(\"height\", 10);\n  updateNodeBounds(node, circle2);\n  node.intersect = function (point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst class_box = (parent, node) => {\n  const halfPadding = node.padding / 2;\n  const rowPadding = 4;\n  const lineHeight = 8;\n  let classes;\n  if (!node.classes) {\n    classes = \"node default\";\n  } else {\n    classes = \"node \" + node.classes;\n  }\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", classes).attr(\"id\", node.domId || node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const topLine = shapeSvg.insert(\"line\");\n  const bottomLine = shapeSvg.insert(\"line\");\n  let maxWidth = 0;\n  let maxHeight = rowPadding;\n  const labelContainer = shapeSvg.insert(\"g\").attr(\"class\", \"label\");\n  let verticalPos = 0;\n  const hasInterface = node.classData.annotations && node.classData.annotations[0];\n  const interfaceLabelText = node.classData.annotations[0] ? \"«\" + node.classData.annotations[0] + \"»\" : \"\";\n  const interfaceLabel = labelContainer.node().appendChild(createLabel$1(interfaceLabelText, node.labelStyle, true, true));\n  let interfaceBBox = interfaceLabel.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = interfaceLabel.children[0];\n    const dv = select(interfaceLabel);\n    interfaceBBox = div.getBoundingClientRect();\n    dv.attr(\"width\", interfaceBBox.width);\n    dv.attr(\"height\", interfaceBBox.height);\n  }\n  if (node.classData.annotations[0]) {\n    maxHeight += interfaceBBox.height + rowPadding;\n    maxWidth += interfaceBBox.width;\n  }\n  let classTitleString = node.classData.label;\n  if (node.classData.type !== void 0 && node.classData.type !== \"\") {\n    if (getConfig().flowchart.htmlLabels) {\n      classTitleString += \"&lt;\" + node.classData.type + \"&gt;\";\n    } else {\n      classTitleString += \"<\" + node.classData.type + \">\";\n    }\n  }\n  const classTitleLabel = labelContainer.node().appendChild(createLabel$1(classTitleString, node.labelStyle, true, true));\n  select(classTitleLabel).attr(\"class\", \"classTitle\");\n  let classTitleBBox = classTitleLabel.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = classTitleLabel.children[0];\n    const dv = select(classTitleLabel);\n    classTitleBBox = div.getBoundingClientRect();\n    dv.attr(\"width\", classTitleBBox.width);\n    dv.attr(\"height\", classTitleBBox.height);\n  }\n  maxHeight += classTitleBBox.height + rowPadding;\n  if (classTitleBBox.width > maxWidth) {\n    maxWidth = classTitleBBox.width;\n  }\n  const classAttributes = [];\n  node.classData.members.forEach(member => {\n    const parsedInfo = member.getDisplayDetails();\n    let parsedText = parsedInfo.displayText;\n    if (getConfig().flowchart.htmlLabels) {\n      parsedText = parsedText.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    const lbl = labelContainer.node().appendChild(createLabel$1(parsedText, parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle, true, true));\n    let bbox = lbl.getBBox();\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = select(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr(\"width\", bbox.width);\n      dv.attr(\"height\", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classAttributes.push(lbl);\n  });\n  maxHeight += lineHeight;\n  const classMethods = [];\n  node.classData.methods.forEach(member => {\n    const parsedInfo = member.getDisplayDetails();\n    let displayText = parsedInfo.displayText;\n    if (getConfig().flowchart.htmlLabels) {\n      displayText = displayText.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    const lbl = labelContainer.node().appendChild(createLabel$1(displayText, parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle, true, true));\n    let bbox = lbl.getBBox();\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = select(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr(\"width\", bbox.width);\n      dv.attr(\"height\", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classMethods.push(lbl);\n  });\n  maxHeight += lineHeight;\n  if (hasInterface) {\n    let diffX2 = (maxWidth - interfaceBBox.width) / 2;\n    select(interfaceLabel).attr(\"transform\", \"translate( \" + (-1 * maxWidth / 2 + diffX2) + \", \" + -1 * maxHeight / 2 + \")\");\n    verticalPos = interfaceBBox.height + rowPadding;\n  }\n  let diffX = (maxWidth - classTitleBBox.width) / 2;\n  select(classTitleLabel).attr(\"transform\", \"translate( \" + (-1 * maxWidth / 2 + diffX) + \", \" + (-1 * maxHeight / 2 + verticalPos) + \")\");\n  verticalPos += classTitleBBox.height + rowPadding;\n  topLine.attr(\"class\", \"divider\").attr(\"x1\", -maxWidth / 2 - halfPadding).attr(\"x2\", maxWidth / 2 + halfPadding).attr(\"y1\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr(\"y2\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classAttributes.forEach(lbl => {\n    select(lbl).attr(\"transform\", \"translate( \" + -maxWidth / 2 + \", \" + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + \")\");\n    const memberBBox = lbl == null ? void 0 : lbl.getBBox();\n    verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;\n  });\n  verticalPos += lineHeight;\n  bottomLine.attr(\"class\", \"divider\").attr(\"x1\", -maxWidth / 2 - halfPadding).attr(\"x2\", maxWidth / 2 + halfPadding).attr(\"y1\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr(\"y2\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classMethods.forEach(lbl => {\n    select(lbl).attr(\"transform\", \"translate( \" + -maxWidth / 2 + \", \" + (-1 * maxHeight / 2 + verticalPos) + \")\");\n    const memberBBox = lbl == null ? void 0 : lbl.getBBox();\n    verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;\n  });\n  rect2.attr(\"style\", node.style).attr(\"class\", \"outer title-state\").attr(\"x\", -maxWidth / 2 - halfPadding).attr(\"y\", -(maxHeight / 2) - halfPadding).attr(\"width\", maxWidth + node.padding).attr(\"height\", maxHeight + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function (point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rhombus: question,\n  composite,\n  question,\n  rect,\n  labelRect,\n  rectWithTitle,\n  choice,\n  circle,\n  doublecircle,\n  stadium,\n  hexagon,\n  block_arrow,\n  rect_left_inv_arrow,\n  lean_right,\n  lean_left,\n  trapezoid,\n  inv_trapezoid,\n  rect_right_inv_arrow,\n  cylinder,\n  start,\n  end,\n  note: note$1,\n  subroutine,\n  fork: forkJoin,\n  join: forkJoin,\n  class_box\n};\nlet nodeElems = {};\nconst insertNode = async (elem, node, dir) => {\n  let newEl;\n  let el;\n  if (node.link) {\n    let target;\n    if (getConfig().securityLevel === \"sandbox\") {\n      target = \"_top\";\n    } else if (node.linkTarget) {\n      target = node.linkTarget || \"_blank\";\n    }\n    newEl = elem.insert(\"svg:a\").attr(\"xlink:href\", node.link).attr(\"target\", target);\n    el = await shapes[node.shape](newEl, node, dir);\n  } else {\n    el = await shapes[node.shape](elem, node, dir);\n    newEl = el;\n  }\n  if (node.tooltip) {\n    el.attr(\"title\", node.tooltip);\n  }\n  if (node.class) {\n    el.attr(\"class\", \"node default \" + node.class);\n  }\n  newEl.attr(\"data-node\", \"true\");\n  newEl.attr(\"data-id\", node.id);\n  nodeElems[node.id] = newEl;\n  if (node.haveCallback) {\n    nodeElems[node.id].attr(\"class\", nodeElems[node.id].attr(\"class\") + \" clickable\");\n  }\n  return newEl;\n};\nconst setNodeElem = (elem, node) => {\n  nodeElems[node.id] = elem;\n};\nconst clear$1 = () => {\n  nodeElems = {};\n};\nconst positionNode = node => {\n  const el = nodeElems[node.id];\n  log.trace(\"Transforming node\", node.diff, node, \"translate(\" + (node.x - node.width / 2 - 5) + \", \" + node.width / 2 + \")\");\n  const padding = 8;\n  const diff = node.diff || 0;\n  if (node.clusterNode) {\n    el.attr(\"transform\", \"translate(\" + (node.x + diff - node.width / 2) + \", \" + (node.y - node.height / 2 - padding) + \")\");\n  } else {\n    el.attr(\"transform\", \"translate(\" + node.x + \", \" + node.y + \")\");\n  }\n  return diff;\n};\nconst getSubGraphTitleMargins = ({\n  flowchart\n}) => {\n  var _a, _b;\n  const subGraphTitleTopMargin = ((_a = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _a.top) ?? 0;\n  const subGraphTitleBottomMargin = ((_b = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _b.bottom) ?? 0;\n  const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;\n  return {\n    subGraphTitleTopMargin,\n    subGraphTitleBottomMargin,\n    subGraphTitleTotalMargin\n  };\n};\nconst markerOffsets = {\n  aggregation: 18,\n  extension: 18,\n  composition: 18,\n  dependency: 6,\n  lollipop: 13.5,\n  arrow_point: 5.3\n};\nfunction calculateDeltaAndAngle(point1, point2) {\n  if (point1 === void 0 || point2 === void 0) {\n    return {\n      angle: 0,\n      deltaX: 0,\n      deltaY: 0\n    };\n  }\n  point1 = pointTransformer(point1);\n  point2 = pointTransformer(point2);\n  const [x1, y1] = [point1.x, point1.y];\n  const [x2, y2] = [point2.x, point2.y];\n  const deltaX = x2 - x1;\n  const deltaY = y2 - y1;\n  return {\n    angle: Math.atan(deltaY / deltaX),\n    deltaX,\n    deltaY\n  };\n}\nconst pointTransformer = data => {\n  if (Array.isArray(data)) {\n    return {\n      x: data[0],\n      y: data[1]\n    };\n  }\n  return data;\n};\nconst getLineFunctionsWithOffset = edge => {\n  return {\n    x: function (d, i, data) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const {\n          angle,\n          deltaX\n        } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const {\n          angle,\n          deltaX\n        } = calculateDeltaAndAngle(data[data.length - 1], data[data.length - 2]);\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).x + offset;\n    },\n    y: function (d, i, data) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const {\n          angle,\n          deltaY\n        } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const {\n          angle,\n          deltaY\n        } = calculateDeltaAndAngle(data[data.length - 1], data[data.length - 2]);\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).y + offset;\n    }\n  };\n};\nconst addEdgeMarkers = (svgPath, edge, url, id, diagramType) => {\n  if (edge.arrowTypeStart) {\n    addEdgeMarker(svgPath, \"start\", edge.arrowTypeStart, url, id, diagramType);\n  }\n  if (edge.arrowTypeEnd) {\n    addEdgeMarker(svgPath, \"end\", edge.arrowTypeEnd, url, id, diagramType);\n  }\n};\nconst arrowTypesMap = {\n  arrow_cross: \"cross\",\n  arrow_point: \"point\",\n  arrow_barb: \"barb\",\n  arrow_circle: \"circle\",\n  aggregation: \"aggregation\",\n  extension: \"extension\",\n  composition: \"composition\",\n  dependency: \"dependency\",\n  lollipop: \"lollipop\"\n};\nconst addEdgeMarker = (svgPath, position, arrowType, url, id, diagramType) => {\n  const endMarkerType = arrowTypesMap[arrowType];\n  if (!endMarkerType) {\n    log.warn(`Unknown arrow type: ${arrowType}`);\n    return;\n  }\n  const suffix = position === \"start\" ? \"Start\" : \"End\";\n  svgPath.attr(`marker-${position}`, `url(${url}#${id}_${diagramType}-${endMarkerType}${suffix})`);\n};\nlet edgeLabels = {};\nlet terminalLabels = {};\nconst clear = () => {\n  edgeLabels = {};\n  terminalLabels = {};\n};\nconst insertEdgeLabel = (elem, edge) => {\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n  const labelElement = edge.labelType === \"markdown\" ? createText(elem, edge.label, {\n    style: edge.labelStyle,\n    useHtmlLabels,\n    addSvgBackground: true\n  }) : createLabel$1(edge.label, edge.labelStyle);\n  const edgeLabel = elem.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const label = edgeLabel.insert(\"g\").attr(\"class\", \"label\");\n  label.node().appendChild(labelElement);\n  let bbox = labelElement.getBBox();\n  if (useHtmlLabels) {\n    const div = labelElement.children[0];\n    const dv = select(labelElement);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + -bbox.height / 2 + \")\");\n  edgeLabels[edge.id] = edgeLabel;\n  edge.width = bbox.width;\n  edge.height = bbox.height;\n  let fo;\n  if (edge.startLabelLeft) {\n    const startLabelElement = createLabel$1(edge.startLabelLeft, edge.labelStyle);\n    const startEdgeLabelLeft = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = startEdgeLabelLeft.insert(\"g\").attr(\"class\", \"inner\");\n    fo = inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;\n    setTerminalWidth(fo, edge.startLabelLeft);\n  }\n  if (edge.startLabelRight) {\n    const startLabelElement = createLabel$1(edge.startLabelRight, edge.labelStyle);\n    const startEdgeLabelRight = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = startEdgeLabelRight.insert(\"g\").attr(\"class\", \"inner\");\n    fo = startEdgeLabelRight.node().appendChild(startLabelElement);\n    inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startRight = startEdgeLabelRight;\n    setTerminalWidth(fo, edge.startLabelRight);\n  }\n  if (edge.endLabelLeft) {\n    const endLabelElement = createLabel$1(edge.endLabelLeft, edge.labelStyle);\n    const endEdgeLabelLeft = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = endEdgeLabelLeft.insert(\"g\").attr(\"class\", \"inner\");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    endEdgeLabelLeft.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;\n    setTerminalWidth(fo, edge.endLabelLeft);\n  }\n  if (edge.endLabelRight) {\n    const endLabelElement = createLabel$1(edge.endLabelRight, edge.labelStyle);\n    const endEdgeLabelRight = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = endEdgeLabelRight.insert(\"g\").attr(\"class\", \"inner\");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    endEdgeLabelRight.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endRight = endEdgeLabelRight;\n    setTerminalWidth(fo, edge.endLabelRight);\n  }\n  return labelElement;\n};\nfunction setTerminalWidth(fo, value) {\n  if (getConfig().flowchart.htmlLabels && fo) {\n    fo.style.width = value.length * 9 + \"px\";\n    fo.style.height = \"12px\";\n  }\n}\nconst positionEdgeLabel = (edge, paths) => {\n  log.debug(\"Moving label abc88 \", edge.id, edge.label, edgeLabels[edge.id], paths);\n  let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;\n  const siteConfig = getConfig();\n  const {\n    subGraphTitleTotalMargin\n  } = getSubGraphTitleMargins(siteConfig);\n  if (edge.label) {\n    const el = edgeLabels[edge.id];\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcLabelPosition(path);\n      log.debug(\"Moving label \" + edge.label + \" from (\", x, \",\", y, \") to (\", pos.x, \",\", pos.y, \") abc88\");\n      if (paths.updatedPath) {\n        x = pos.x;\n        y = pos.y;\n      }\n    }\n    el.attr(\"transform\", `translate(${x}, ${y + subGraphTitleTotalMargin / 2})`);\n  }\n  if (edge.startLabelLeft) {\n    const el = terminalLabels[edge.id].startLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, \"start_left\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n  if (edge.startLabelRight) {\n    const el = terminalLabels[edge.id].startRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, \"start_right\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n  if (edge.endLabelLeft) {\n    const el = terminalLabels[edge.id].endLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, \"end_left\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n  if (edge.endLabelRight) {\n    const el = terminalLabels[edge.id].endRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, \"end_right\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n};\nconst outsideNode = (node, point2) => {\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(point2.x - x);\n  const dy = Math.abs(point2.y - y);\n  const w = node.width / 2;\n  const h = node.height / 2;\n  if (dx >= w || dy >= h) {\n    return true;\n  }\n  return false;\n};\nconst intersection = (node, outsidePoint, insidePoint) => {\n  log.debug(`intersection calc abc89:\n  outsidePoint: ${JSON.stringify(outsidePoint)}\n  insidePoint : ${JSON.stringify(insidePoint)}\n  node        : x:${node.x} y:${node.y} w:${node.width} h:${node.height}`);\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(x - insidePoint.x);\n  const w = node.width / 2;\n  let r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;\n  const h = node.height / 2;\n  const Q = Math.abs(outsidePoint.y - insidePoint.y);\n  const R = Math.abs(outsidePoint.x - insidePoint.x);\n  if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {\n    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;\n    r = R * q / Q;\n    const res = {\n      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,\n      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q\n    };\n    if (r === 0) {\n      res.x = outsidePoint.x;\n      res.y = outsidePoint.y;\n    }\n    if (R === 0) {\n      res.x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      res.y = outsidePoint.y;\n    }\n    log.debug(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);\n    return res;\n  } else {\n    if (insidePoint.x < outsidePoint.x) {\n      r = outsidePoint.x - w - x;\n    } else {\n      r = x - w - outsidePoint.x;\n    }\n    let q = Q * r / R;\n    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;\n    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;\n    log.debug(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, {\n      _x,\n      _y\n    });\n    if (r === 0) {\n      _x = outsidePoint.x;\n      _y = outsidePoint.y;\n    }\n    if (R === 0) {\n      _x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      _y = outsidePoint.y;\n    }\n    return {\n      x: _x,\n      y: _y\n    };\n  }\n};\nconst cutPathAtIntersect = (_points, boundaryNode) => {\n  log.debug(\"abc88 cutPathAtIntersect\", _points, boundaryNode);\n  let points = [];\n  let lastPointOutside = _points[0];\n  let isInside = false;\n  _points.forEach(point2 => {\n    if (!outsideNode(boundaryNode, point2) && !isInside) {\n      const inter = intersection(boundaryNode, lastPointOutside, point2);\n      let pointPresent = false;\n      points.forEach(p => {\n        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;\n      });\n      if (!points.some(e => e.x === inter.x && e.y === inter.y)) {\n        points.push(inter);\n      }\n      isInside = true;\n    } else {\n      lastPointOutside = point2;\n      if (!isInside) {\n        points.push(point2);\n      }\n    }\n  });\n  return points;\n};\nconst insertEdge = function (elem, e, edge, clusterDb, diagramType, graph, id) {\n  let points = edge.points;\n  log.debug(\"abc88 InsertEdge: edge=\", edge, \"e=\", e);\n  let pointsHasChanged = false;\n  const tail = graph.node(e.v);\n  var head = graph.node(e.w);\n  if ((head == null ? void 0 : head.intersect) && (tail == null ? void 0 : tail.intersect)) {\n    points = points.slice(1, edge.points.length - 1);\n    points.unshift(tail.intersect(points[0]));\n    points.push(head.intersect(points[points.length - 1]));\n  }\n  if (edge.toCluster) {\n    log.debug(\"to cluster abc88\", clusterDb[edge.toCluster]);\n    points = cutPathAtIntersect(edge.points, clusterDb[edge.toCluster].node);\n    pointsHasChanged = true;\n  }\n  if (edge.fromCluster) {\n    log.debug(\"from cluster abc88\", clusterDb[edge.fromCluster]);\n    points = cutPathAtIntersect(points.reverse(), clusterDb[edge.fromCluster].node).reverse();\n    pointsHasChanged = true;\n  }\n  const lineData = points.filter(p => !Number.isNaN(p.y));\n  let curve = curveBasis;\n  if (edge.curve && (diagramType === \"graph\" || diagramType === \"flowchart\")) {\n    curve = edge.curve;\n  }\n  const {\n    x,\n    y\n  } = getLineFunctionsWithOffset(edge);\n  const lineFunction = line().x(x).y(y).curve(curve);\n  let strokeClasses;\n  switch (edge.thickness) {\n    case \"normal\":\n      strokeClasses = \"edge-thickness-normal\";\n      break;\n    case \"thick\":\n      strokeClasses = \"edge-thickness-thick\";\n      break;\n    case \"invisible\":\n      strokeClasses = \"edge-thickness-thick\";\n      break;\n    default:\n      strokeClasses = \"\";\n  }\n  switch (edge.pattern) {\n    case \"solid\":\n      strokeClasses += \" edge-pattern-solid\";\n      break;\n    case \"dotted\":\n      strokeClasses += \" edge-pattern-dotted\";\n      break;\n    case \"dashed\":\n      strokeClasses += \" edge-pattern-dashed\";\n      break;\n  }\n  const svgPath = elem.append(\"path\").attr(\"d\", lineFunction(lineData)).attr(\"id\", edge.id).attr(\"class\", \" \" + strokeClasses + (edge.classes ? \" \" + edge.classes : \"\")).attr(\"style\", edge.style);\n  let url = \"\";\n  if (getConfig().flowchart.arrowMarkerAbsolute || getConfig().state.arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n  addEdgeMarkers(svgPath, edge, url, id, diagramType);\n  let paths = {};\n  if (pointsHasChanged) {\n    paths.updatedPath = points;\n  }\n  paths.originalPath = edge.points;\n  return paths;\n};\nexport { insertMarkers$1 as a, clear$1 as b, createLabel$1 as c, clear as d, insertNode as e, insertEdgeLabel as f, getSubGraphTitleMargins as g, insertEdge as h, intersectRect$1 as i, positionEdgeLabel as j, getLineFunctionsWithOffset as k, labelHelper as l, addEdgeMarkers as m, positionNode as p, setNodeElem as s, updateNodeBounds as u };","map":{"version":3,"names":["l","log","m","evaluate","c","getConfig","M","decodeEntities","d","sanitizeText","u","utils","select","line","curveBasis","a","createText","insertMarkers","elem","markerArray","type","id","forEach","markerName","markers","extension","trace","append","attr","composition","aggregation","dependency","lollipop","point","style","circle$1","cross","barb","circle","insertMarkers$1","applyStyle","dom","styleFn","addHtmlLabel","node","fo","document","createElementNS","div","label","labelClass","isNode","html","labelStyle","createLabel","_vertexText","isTitle","vertexText","flowchart","htmlLabels","replace","debug","s","vertexNode","svgLabel","setAttribute","rows","split","Array","isArray","row","tspan","setAttributeNS","textContent","trim","appendChild","createLabel$1","labelHelper","parent","_classes","classes","useHtmlLabels","shapeSvg","insert","domId","labelText","textNode","text","labelType","width","wrappingWidth","bbox","getBBox","halfPadding","padding","children","dv","images","getElementsByTagName","noImgText","Promise","all","map","img","res","setupImage","display","flexDirection","bodyFontSize","fontSize","window","getComputedStyle","body","enlargingFactor","parseInt","minWidth","maxWidth","setTimeout","complete","addEventListener","getBoundingClientRect","height","centerLabel","updateNodeBounds","element","insertPolygonShape","w","h","points","x","y","join","intersectNode","point2","intersect","intersectEllipse","rx","ry","cx","cy","px","py","det","Math","sqrt","dx","abs","dy","intersectCircle","intersectLine","p1","p2","q1","q2","a1","a2","b1","b2","c1","c2","r1","r2","r3","r4","denom","offset","num","sameSign","intersectPolygon","polyPoints","x1","y1","intersections","minX","Number","POSITIVE_INFINITY","minY","entry","min","left","top","i","length","intersect2","push","sort","p","q","pdx","pdy","distp","qdx","qdy","distq","intersectRect","sx","sy","intersectRect$1","ellipse","polygon","rect","note","info","rect2","note$1","expandAndDeduplicateDirections","directions","uniqueDirections","Set","direction","add","getArrowPoints","duplicatedDirections","f","midpoint","has","formatClass","str","getClassesFromNode","otherClasses","class","question","questionElem","warn","choice","choice2","hexagon","hex","block_arrow","blockArrow","rect_left_inv_arrow","el","lean_right","lean_left","trapezoid","inv_trapezoid","rect_right_inv_arrow","cylinder","shape","pos","totalWidth","positioned","totalHeight","props","propKeys","Object","keys","borders","applyNodePropertyBorders","delete","propKey","composite","labelRect","strokeDashArray","addBorder","skipBorder","includes","rectWithTitle","innerLine","text2","flat","title","textRows","slice","titleBox","descr","stadium","circle2","doublecircle","gap","circleGroup","outerCircle","innerCircle","subroutine","start","forkJoin","dir","end","class_box","rowPadding","lineHeight","topLine","bottomLine","maxHeight","labelContainer","verticalPos","hasInterface","classData","annotations","interfaceLabelText","interfaceLabel","interfaceBBox","classTitleString","classTitleLabel","classTitleBBox","classAttributes","members","member","parsedInfo","getDisplayDetails","parsedText","displayText","lbl","cssStyle","classMethods","methods","diffX2","diffX","memberBBox","shapes","rhombus","fork","nodeElems","insertNode","newEl","link","target","securityLevel","linkTarget","tooltip","haveCallback","setNodeElem","clear$1","positionNode","diff","clusterNode","getSubGraphTitleMargins","_a","_b","subGraphTitleTopMargin","subGraphTitleMargin","subGraphTitleBottomMargin","bottom","subGraphTitleTotalMargin","markerOffsets","arrow_point","calculateDeltaAndAngle","point1","angle","deltaX","deltaY","pointTransformer","x2","y2","atan","data","getLineFunctionsWithOffset","edge","hasOwn","arrowTypeStart","cos","arrowTypeEnd","sin","addEdgeMarkers","svgPath","url","diagramType","addEdgeMarker","arrowTypesMap","arrow_cross","arrow_barb","arrow_circle","position","arrowType","endMarkerType","suffix","edgeLabels","terminalLabels","clear","insertEdgeLabel","labelElement","addSvgBackground","edgeLabel","startLabelLeft","startLabelElement","startEdgeLabelLeft","inner","slBox","startLeft","setTerminalWidth","startLabelRight","startEdgeLabelRight","startRight","endLabelLeft","endLabelElement","endEdgeLabelLeft","endLeft","endLabelRight","endEdgeLabelRight","endRight","value","positionEdgeLabel","paths","path","updatedPath","originalPath","siteConfig","calcLabelPosition","calcTerminalLabelPosition","outsideNode","intersection","outsidePoint","insidePoint","JSON","stringify","r","Q","R","_x","_y","cutPathAtIntersect","_points","boundaryNode","lastPointOutside","isInside","inter","pointPresent","some","e","insertEdge","clusterDb","graph","pointsHasChanged","tail","v","head","unshift","toCluster","fromCluster","reverse","lineData","filter","isNaN","curve","lineFunction","strokeClasses","thickness","pattern","arrowMarkerAbsolute","state","location","protocol","host","pathname","search","b","g","j","k"],"sources":["/Users/anasshaik/Desktop/Projects/CareerPath.AI/frontend/node_modules/mermaid/dist/edges-e0da2a9e.js"],"sourcesContent":["import { l as log, m as evaluate, c as getConfig, M as decodeEntities, d as sanitizeText, u as utils } from \"./mermaid-b5860b54.js\";\nimport { select, line, curveBasis } from \"d3\";\nimport { a as createText } from \"./createText-2e5e7dd3.js\";\nconst insertMarkers = (elem, markerArray, type, id) => {\n  markerArray.forEach((markerName) => {\n    markers[markerName](elem, type, id);\n  });\n};\nconst extension = (elem, type, id) => {\n  log.trace(\"Making markers for \", id);\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-extensionStart\").attr(\"class\", \"marker extension \" + type).attr(\"refX\", 18).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,7 L18,13 V 1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-extensionEnd\").attr(\"class\", \"marker extension \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,1 V 13 L18,7 Z\");\n};\nconst composition = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-compositionStart\").attr(\"class\", \"marker composition \" + type).attr(\"refX\", 18).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-compositionEnd\").attr(\"class\", \"marker composition \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n};\nconst aggregation = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-aggregationStart\").attr(\"class\", \"marker aggregation \" + type).attr(\"refX\", 18).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-aggregationEnd\").attr(\"class\", \"marker aggregation \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L1,7 L9,1 Z\");\n};\nconst dependency = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-dependencyStart\").attr(\"class\", \"marker dependency \" + type).attr(\"refX\", 6).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 5,7 L9,13 L1,7 L9,1 Z\");\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-dependencyEnd\").attr(\"class\", \"marker dependency \" + type).attr(\"refX\", 13).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 28).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 18,7 L9,13 L14,7 L9,1 Z\");\n};\nconst lollipop = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-lollipopStart\").attr(\"class\", \"marker lollipop \" + type).attr(\"refX\", 13).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"circle\").attr(\"stroke\", \"black\").attr(\"fill\", \"transparent\").attr(\"cx\", 7).attr(\"cy\", 7).attr(\"r\", 6);\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-lollipopEnd\").attr(\"class\", \"marker lollipop \" + type).attr(\"refX\", 1).attr(\"refY\", 7).attr(\"markerWidth\", 190).attr(\"markerHeight\", 240).attr(\"orient\", \"auto\").append(\"circle\").attr(\"stroke\", \"black\").attr(\"fill\", \"transparent\").attr(\"cx\", 7).attr(\"cy\", 7).attr(\"r\", 6);\n};\nconst point = (elem, type, id) => {\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-pointEnd\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 6).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 12).attr(\"markerHeight\", 12).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-pointStart\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 4.5).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 12).attr(\"markerHeight\", 12).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 0 5 L 10 10 L 10 0 z\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n};\nconst circle$1 = (elem, type, id) => {\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-circleEnd\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 11).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"circle\").attr(\"cx\", \"5\").attr(\"cy\", \"5\").attr(\"r\", \"5\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-circleStart\").attr(\"class\", \"marker \" + type).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", -1).attr(\"refY\", 5).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"circle\").attr(\"cx\", \"5\").attr(\"cy\", \"5\").attr(\"r\", \"5\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n};\nconst cross = (elem, type, id) => {\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-crossEnd\").attr(\"class\", \"marker cross \" + type).attr(\"viewBox\", \"0 0 11 11\").attr(\"refX\", 12).attr(\"refY\", 5.2).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,1 l 9,9 M 10,1 l -9,9\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 2).style(\"stroke-dasharray\", \"1,0\");\n  elem.append(\"marker\").attr(\"id\", id + \"_\" + type + \"-crossStart\").attr(\"class\", \"marker cross \" + type).attr(\"viewBox\", \"0 0 11 11\").attr(\"refX\", -1).attr(\"refY\", 5.2).attr(\"markerUnits\", \"userSpaceOnUse\").attr(\"markerWidth\", 11).attr(\"markerHeight\", 11).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 1,1 l 9,9 M 10,1 l -9,9\").attr(\"class\", \"arrowMarkerPath\").style(\"stroke-width\", 2).style(\"stroke-dasharray\", \"1,0\");\n};\nconst barb = (elem, type, id) => {\n  elem.append(\"defs\").append(\"marker\").attr(\"id\", id + \"_\" + type + \"-barbEnd\").attr(\"refX\", 19).attr(\"refY\", 7).attr(\"markerWidth\", 20).attr(\"markerHeight\", 14).attr(\"markerUnits\", \"strokeWidth\").attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 19,7 L9,13 L14,7 L9,1 Z\");\n};\nconst markers = {\n  extension,\n  composition,\n  aggregation,\n  dependency,\n  lollipop,\n  point,\n  circle: circle$1,\n  cross,\n  barb\n};\nconst insertMarkers$1 = insertMarkers;\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlLabel(node) {\n  const fo = select(document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\"));\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    '<span class=\"' + labelClass + '\" ' + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"inline-block\");\n  div.style(\"white-space\", \"nowrap\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  return fo.node();\n}\nconst createLabel = (_vertexText, style, isTitle, isNode) => {\n  let vertexText = _vertexText || \"\";\n  if (typeof vertexText === \"object\") {\n    vertexText = vertexText[0];\n  }\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    vertexText = vertexText.replace(/\\\\n|\\n/g, \"<br />\");\n    log.debug(\"vertexText\" + vertexText);\n    const node = {\n      isNode,\n      label: decodeEntities(vertexText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        // cspell: disable-line\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    let vertexNode = addHtmlLabel(node);\n    return vertexNode;\n  } else {\n    const svgLabel = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    svgLabel.setAttribute(\"style\", style.replace(\"color:\", \"fill:\"));\n    let rows = [];\n    if (typeof vertexText === \"string\") {\n      rows = vertexText.split(/\\\\n|\\n|<br\\s*\\/?>/gi);\n    } else if (Array.isArray(vertexText)) {\n      rows = vertexText;\n    } else {\n      rows = [];\n    }\n    for (const row of rows) {\n      const tspan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n      tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n      tspan.setAttribute(\"dy\", \"1em\");\n      tspan.setAttribute(\"x\", \"0\");\n      if (isTitle) {\n        tspan.setAttribute(\"class\", \"title-row\");\n      } else {\n        tspan.setAttribute(\"class\", \"row\");\n      }\n      tspan.textContent = row.trim();\n      svgLabel.appendChild(tspan);\n    }\n    return svgLabel;\n  }\n};\nconst createLabel$1 = createLabel;\nconst labelHelper = async (parent, node, _classes, isNode) => {\n  let classes;\n  const useHtmlLabels = node.useHtmlLabels || evaluate(getConfig().flowchart.htmlLabels);\n  if (!_classes) {\n    classes = \"node default\";\n  } else {\n    classes = _classes;\n  }\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", classes).attr(\"id\", node.domId || node.id);\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"label\").attr(\"style\", node.labelStyle);\n  let labelText;\n  if (node.labelText === void 0) {\n    labelText = \"\";\n  } else {\n    labelText = typeof node.labelText === \"string\" ? node.labelText : node.labelText[0];\n  }\n  const textNode = label.node();\n  let text;\n  if (node.labelType === \"markdown\") {\n    text = createText(label, sanitizeText(decodeEntities(labelText), getConfig()), {\n      useHtmlLabels,\n      width: node.width || getConfig().flowchart.wrappingWidth,\n      classes: \"markdown-node-label\"\n    });\n  } else {\n    text = textNode.appendChild(\n      createLabel$1(\n        sanitizeText(decodeEntities(labelText), getConfig()),\n        node.labelStyle,\n        false,\n        isNode\n      )\n    );\n  }\n  let bbox = text.getBBox();\n  const halfPadding = node.padding / 2;\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    const images = div.getElementsByTagName(\"img\");\n    if (images) {\n      const noImgText = labelText.replace(/<img[^>]*>/g, \"\").trim() === \"\";\n      await Promise.all(\n        [...images].map(\n          (img) => new Promise((res) => {\n            function setupImage() {\n              img.style.display = \"flex\";\n              img.style.flexDirection = \"column\";\n              if (noImgText) {\n                const bodyFontSize = getConfig().fontSize ? getConfig().fontSize : window.getComputedStyle(document.body).fontSize;\n                const enlargingFactor = 5;\n                const width = parseInt(bodyFontSize, 10) * enlargingFactor + \"px\";\n                img.style.minWidth = width;\n                img.style.maxWidth = width;\n              } else {\n                img.style.width = \"100%\";\n              }\n              res(img);\n            }\n            setTimeout(() => {\n              if (img.complete) {\n                setupImage();\n              }\n            });\n            img.addEventListener(\"error\", setupImage);\n            img.addEventListener(\"load\", setupImage);\n          })\n        )\n      );\n    }\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  if (useHtmlLabels) {\n    label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + -bbox.height / 2 + \")\");\n  } else {\n    label.attr(\"transform\", \"translate(0, \" + -bbox.height / 2 + \")\");\n  }\n  if (node.centerLabel) {\n    label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + -bbox.height / 2 + \")\");\n  }\n  label.insert(\"rect\", \":first-child\");\n  return { shapeSvg, bbox, halfPadding, label };\n};\nconst updateNodeBounds = (node, element) => {\n  const bbox = element.node().getBBox();\n  node.width = bbox.width;\n  node.height = bbox.height;\n};\nfunction insertPolygonShape(parent, w, h, points) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    points.map(function(d) {\n      return d.x + \",\" + d.y;\n    }).join(\" \")\n  ).attr(\"class\", \"label-container\").attr(\"transform\", \"translate(\" + -w / 2 + \",\" + h / 2 + \")\");\n}\nfunction intersectNode(node, point2) {\n  return node.intersect(point2);\n}\nfunction intersectEllipse(node, rx, ry, point2) {\n  var cx = node.x;\n  var cy = node.y;\n  var px = cx - point2.x;\n  var py = cy - point2.y;\n  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);\n  var dx = Math.abs(rx * ry * px / det);\n  if (point2.x < cx) {\n    dx = -dx;\n  }\n  var dy = Math.abs(rx * ry * py / det);\n  if (point2.y < cy) {\n    dy = -dy;\n  }\n  return { x: cx + dx, y: cy + dy };\n}\nfunction intersectCircle(node, rx, point2) {\n  return intersectEllipse(node, rx, rx, point2);\n}\nfunction intersectLine(p1, p2, q1, q2) {\n  var a1, a2, b1, b2, c1, c2;\n  var r1, r2, r3, r4;\n  var denom, offset, num;\n  var x, y;\n  a1 = p2.y - p1.y;\n  b1 = p1.x - p2.x;\n  c1 = p2.x * p1.y - p1.x * p2.y;\n  r3 = a1 * q1.x + b1 * q1.y + c1;\n  r4 = a1 * q2.x + b1 * q2.y + c1;\n  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {\n    return;\n  }\n  a2 = q2.y - q1.y;\n  b2 = q1.x - q2.x;\n  c2 = q2.x * q1.y - q1.x * q2.y;\n  r1 = a2 * p1.x + b2 * p1.y + c2;\n  r2 = a2 * p2.x + b2 * p2.y + c2;\n  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {\n    return;\n  }\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return;\n  }\n  offset = Math.abs(denom / 2);\n  num = b1 * c2 - b2 * c1;\n  x = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  num = a2 * c1 - a1 * c2;\n  y = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  return { x, y };\n}\nfunction sameSign(r1, r2) {\n  return r1 * r2 > 0;\n}\nfunction intersectPolygon(node, polyPoints, point2) {\n  var x1 = node.x;\n  var y1 = node.y;\n  var intersections = [];\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  if (typeof polyPoints.forEach === \"function\") {\n    polyPoints.forEach(function(entry) {\n      minX = Math.min(minX, entry.x);\n      minY = Math.min(minY, entry.y);\n    });\n  } else {\n    minX = Math.min(minX, polyPoints.x);\n    minY = Math.min(minY, polyPoints.y);\n  }\n  var left = x1 - node.width / 2 - minX;\n  var top = y1 - node.height / 2 - minY;\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect2 = intersectLine(\n      node,\n      point2,\n      { x: left + p1.x, y: top + p1.y },\n      { x: left + p2.x, y: top + p2.y }\n    );\n    if (intersect2) {\n      intersections.push(intersect2);\n    }\n  }\n  if (!intersections.length) {\n    return node;\n  }\n  if (intersections.length > 1) {\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point2.x;\n      var pdy = p.y - point2.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n      var qdx = q.x - point2.x;\n      var qdy = q.y - point2.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n      return distp < distq ? -1 : distp === distq ? 0 : 1;\n    });\n  }\n  return intersections[0];\n}\nconst intersectRect = (node, point2) => {\n  var x = node.x;\n  var y = node.y;\n  var dx = point2.x - x;\n  var dy = point2.y - y;\n  var w = node.width / 2;\n  var h = node.height / 2;\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = dy === 0 ? 0 : h * dx / dy;\n    sy = h;\n  } else {\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = dx === 0 ? 0 : w * dy / dx;\n  }\n  return { x: x + sx, y: y + sy };\n};\nconst intersectRect$1 = intersectRect;\nconst intersect = {\n  node: intersectNode,\n  circle: intersectCircle,\n  ellipse: intersectEllipse,\n  polygon: intersectPolygon,\n  rect: intersectRect$1\n};\nconst note = async (parent, node) => {\n  const useHtmlLabels = node.useHtmlLabels || getConfig().flowchart.htmlLabels;\n  if (!useHtmlLabels) {\n    node.centerLabel = true;\n  }\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    \"node \" + node.classes,\n    true\n  );\n  log.info(\"Classes = \", node.classes);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  rect2.attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", -bbox.width / 2 - halfPadding).attr(\"y\", -bbox.height / 2 - halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst note$1 = note;\nconst expandAndDeduplicateDirections = (directions) => {\n  const uniqueDirections = /* @__PURE__ */ new Set();\n  for (const direction of directions) {\n    switch (direction) {\n      case \"x\":\n        uniqueDirections.add(\"right\");\n        uniqueDirections.add(\"left\");\n        break;\n      case \"y\":\n        uniqueDirections.add(\"up\");\n        uniqueDirections.add(\"down\");\n        break;\n      default:\n        uniqueDirections.add(direction);\n        break;\n    }\n  }\n  return uniqueDirections;\n};\nconst getArrowPoints = (duplicatedDirections, bbox, node) => {\n  const directions = expandAndDeduplicateDirections(duplicatedDirections);\n  const f = 2;\n  const height = bbox.height + 2 * node.padding;\n  const midpoint = height / f;\n  const width = bbox.width + 2 * midpoint + node.padding;\n  const padding = node.padding / 2;\n  if (directions.has(\"right\") && directions.has(\"left\") && directions.has(\"up\") && directions.has(\"down\")) {\n    return [\n      // Bottom\n      { x: 0, y: 0 },\n      { x: midpoint, y: 0 },\n      { x: width / 2, y: 2 * padding },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: 0 },\n      // Right\n      { x: width, y: -height / 3 },\n      { x: width + 2 * padding, y: -height / 2 },\n      { x: width, y: -2 * height / 3 },\n      { x: width, y: -height },\n      // Top\n      { x: width - midpoint, y: -height },\n      { x: width / 2, y: -height - 2 * padding },\n      { x: midpoint, y: -height },\n      // Left\n      { x: 0, y: -height },\n      { x: 0, y: -2 * height / 3 },\n      { x: -2 * padding, y: -height / 2 },\n      { x: 0, y: -height / 3 }\n    ];\n  }\n  if (directions.has(\"right\") && directions.has(\"left\") && directions.has(\"up\")) {\n    return [\n      { x: midpoint, y: 0 },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: -height / 2 },\n      { x: width - midpoint, y: -height },\n      { x: midpoint, y: -height },\n      { x: 0, y: -height / 2 }\n    ];\n  }\n  if (directions.has(\"right\") && directions.has(\"left\") && directions.has(\"down\")) {\n    return [\n      { x: 0, y: 0 },\n      { x: midpoint, y: -height },\n      { x: width - midpoint, y: -height },\n      { x: width, y: 0 }\n    ];\n  }\n  if (directions.has(\"right\") && directions.has(\"up\") && directions.has(\"down\")) {\n    return [\n      { x: 0, y: 0 },\n      { x: width, y: -midpoint },\n      { x: width, y: -height + midpoint },\n      { x: 0, y: -height }\n    ];\n  }\n  if (directions.has(\"left\") && directions.has(\"up\") && directions.has(\"down\")) {\n    return [\n      { x: width, y: 0 },\n      { x: 0, y: -midpoint },\n      { x: 0, y: -height + midpoint },\n      { x: width, y: -height }\n    ];\n  }\n  if (directions.has(\"right\") && directions.has(\"left\")) {\n    return [\n      { x: midpoint, y: 0 },\n      { x: midpoint, y: -padding },\n      { x: width - midpoint, y: -padding },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: -height / 2 },\n      { x: width - midpoint, y: -height },\n      { x: width - midpoint, y: -height + padding },\n      { x: midpoint, y: -height + padding },\n      { x: midpoint, y: -height },\n      { x: 0, y: -height / 2 }\n    ];\n  }\n  if (directions.has(\"up\") && directions.has(\"down\")) {\n    return [\n      // Bottom center\n      { x: width / 2, y: 0 },\n      // Left pont of bottom arrow\n      { x: 0, y: -padding },\n      { x: midpoint, y: -padding },\n      // Left top over vertical section\n      { x: midpoint, y: -height + padding },\n      { x: 0, y: -height + padding },\n      // Top of arrow\n      { x: width / 2, y: -height },\n      { x: width, y: -height + padding },\n      // Top of right vertical bar\n      { x: width - midpoint, y: -height + padding },\n      { x: width - midpoint, y: -padding },\n      { x: width, y: -padding }\n    ];\n  }\n  if (directions.has(\"right\") && directions.has(\"up\")) {\n    return [\n      { x: 0, y: 0 },\n      { x: width, y: -midpoint },\n      { x: 0, y: -height }\n    ];\n  }\n  if (directions.has(\"right\") && directions.has(\"down\")) {\n    return [\n      { x: 0, y: 0 },\n      { x: width, y: 0 },\n      { x: 0, y: -height }\n    ];\n  }\n  if (directions.has(\"left\") && directions.has(\"up\")) {\n    return [\n      { x: width, y: 0 },\n      { x: 0, y: -midpoint },\n      { x: width, y: -height }\n    ];\n  }\n  if (directions.has(\"left\") && directions.has(\"down\")) {\n    return [\n      { x: width, y: 0 },\n      { x: 0, y: 0 },\n      { x: width, y: -height }\n    ];\n  }\n  if (directions.has(\"right\")) {\n    return [\n      { x: midpoint, y: -padding },\n      { x: midpoint, y: -padding },\n      { x: width - midpoint, y: -padding },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: -height / 2 },\n      { x: width - midpoint, y: -height },\n      { x: width - midpoint, y: -height + padding },\n      // top left corner of arrow\n      { x: midpoint, y: -height + padding },\n      { x: midpoint, y: -height + padding }\n    ];\n  }\n  if (directions.has(\"left\")) {\n    return [\n      { x: midpoint, y: 0 },\n      { x: midpoint, y: -padding },\n      // Two points, the right corners\n      { x: width - midpoint, y: -padding },\n      { x: width - midpoint, y: -height + padding },\n      { x: midpoint, y: -height + padding },\n      { x: midpoint, y: -height },\n      { x: 0, y: -height / 2 }\n    ];\n  }\n  if (directions.has(\"up\")) {\n    return [\n      // Bottom center\n      { x: midpoint, y: -padding },\n      // Left top over vertical section\n      { x: midpoint, y: -height + padding },\n      { x: 0, y: -height + padding },\n      // Top of arrow\n      { x: width / 2, y: -height },\n      { x: width, y: -height + padding },\n      // Top of right vertical bar\n      { x: width - midpoint, y: -height + padding },\n      { x: width - midpoint, y: -padding }\n    ];\n  }\n  if (directions.has(\"down\")) {\n    return [\n      // Bottom center\n      { x: width / 2, y: 0 },\n      // Left pont of bottom arrow\n      { x: 0, y: -padding },\n      { x: midpoint, y: -padding },\n      // Left top over vertical section\n      { x: midpoint, y: -height + padding },\n      { x: width - midpoint, y: -height + padding },\n      { x: width - midpoint, y: -padding },\n      { x: width, y: -padding }\n    ];\n  }\n  return [{ x: 0, y: 0 }];\n};\nconst formatClass = (str) => {\n  if (str) {\n    return \" \" + str;\n  }\n  return \"\";\n};\nconst getClassesFromNode = (node, otherClasses) => {\n  return `${otherClasses ? otherClasses : \"node default\"}${formatClass(node.classes)} ${formatClass(\n    node.class\n  )}`;\n};\nconst question = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const s = w + h;\n  const points = [\n    { x: s / 2, y: 0 },\n    { x: s, y: -s / 2 },\n    { x: s / 2, y: -s },\n    { x: 0, y: -s / 2 }\n  ];\n  log.info(\"Question main (Circle)\");\n  const questionElem = insertPolygonShape(shapeSvg, s, s, points);\n  questionElem.attr(\"style\", node.style);\n  updateNodeBounds(node, questionElem);\n  node.intersect = function(point2) {\n    log.warn(\"Intersect called\");\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst choice = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  const s = 28;\n  const points = [\n    { x: 0, y: s / 2 },\n    { x: s / 2, y: 0 },\n    { x: 0, y: -s / 2 },\n    { x: -s / 2, y: 0 }\n  ];\n  const choice2 = shapeSvg.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    points.map(function(d) {\n      return d.x + \",\" + d.y;\n    }).join(\" \")\n  );\n  choice2.attr(\"class\", \"state-start\").attr(\"r\", 7).attr(\"width\", 28).attr(\"height\", 28);\n  node.width = 28;\n  node.height = 28;\n  node.intersect = function(point2) {\n    return intersect.circle(node, 14, point2);\n  };\n  return shapeSvg;\n};\nconst hexagon = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const f = 4;\n  const h = bbox.height + node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = [\n    { x: m, y: 0 },\n    { x: w - m, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w - m, y: -h },\n    { x: m, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  const hex = insertPolygonShape(shapeSvg, w, h, points);\n  hex.attr(\"style\", node.style);\n  updateNodeBounds(node, hex);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst block_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const f = 2;\n  const h = bbox.height + 2 * node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = getArrowPoints(node.directions, bbox, node);\n  const blockArrow = insertPolygonShape(shapeSvg, w, h, points);\n  blockArrow.attr(\"style\", node.style);\n  updateNodeBounds(node, blockArrow);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_left_inv_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -h / 2, y: 0 },\n    { x: w, y: 0 },\n    { x: w, y: -h },\n    { x: -h / 2, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  node.width = w + h;\n  node.height = h;\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_right = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -2 * h / 6, y: 0 },\n    { x: w - h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: -h },\n    { x: h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_left = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 2 * h / 6, y: 0 },\n    { x: w + h / 6, y: 0 },\n    { x: w - 2 * h / 6, y: -h },\n    { x: -h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst trapezoid = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -2 * h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: 0 },\n    { x: w - h / 6, y: -h },\n    { x: h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst inv_trapezoid = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: h / 6, y: 0 },\n    { x: w - h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: -h },\n    { x: -2 * h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_right_inv_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 0, y: 0 },\n    { x: w + h / 2, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w + h / 2, y: -h },\n    { x: 0, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst cylinder = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const rx = w / 2;\n  const ry = rx / (2.5 + w / 50);\n  const h = bbox.height + ry + node.padding;\n  const shape = \"M 0,\" + ry + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 a \" + rx + \",\" + ry + \" 0,0,0 \" + -w + \" 0 l 0,\" + h + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 l 0,\" + -h;\n  const el = shapeSvg.attr(\"label-offset-y\", ry).insert(\"path\", \":first-child\").attr(\"style\", node.style).attr(\"d\", shape).attr(\"transform\", \"translate(\" + -w / 2 + \",\" + -(h / 2 + ry) + \")\");\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    const pos = intersect.rect(node, point2);\n    const x = pos.x - node.x;\n    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {\n      let y = ry * ry * (1 - x * x / (rx * rx));\n      if (y != 0) {\n        y = Math.sqrt(y);\n      }\n      y = ry - y;\n      if (point2.y - node.y > 0) {\n        y = -y;\n      }\n      pos.y += y;\n    }\n    return pos;\n  };\n  return shapeSvg;\n};\nconst rect = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    \"node \" + node.classes + \" \" + node.class,\n    true\n  );\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const totalWidth = node.positioned ? node.width : bbox.width + node.padding;\n  const totalHeight = node.positioned ? node.height : bbox.height + node.padding;\n  const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;\n  const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;\n  rect2.attr(\"class\", \"basic label-container\").attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", x).attr(\"y\", y).attr(\"width\", totalWidth).attr(\"height\", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete(\"borders\");\n    }\n    propKeys.forEach((propKey) => {\n      log.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst composite = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    \"node \" + node.classes,\n    true\n  );\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const totalWidth = node.positioned ? node.width : bbox.width + node.padding;\n  const totalHeight = node.positioned ? node.height : bbox.height + node.padding;\n  const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;\n  const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;\n  rect2.attr(\"class\", \"basic cluster composite label-container\").attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", x).attr(\"y\", y).attr(\"width\", totalWidth).attr(\"height\", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete(\"borders\");\n    }\n    propKeys.forEach((propKey) => {\n      log.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst labelRect = async (parent, node) => {\n  const { shapeSvg } = await labelHelper(parent, node, \"label\", true);\n  log.trace(\"Classes = \", node.class);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const totalWidth = 0;\n  const totalHeight = 0;\n  rect2.attr(\"width\", totalWidth).attr(\"height\", totalHeight);\n  shapeSvg.attr(\"class\", \"label edgeLabel\");\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete(\"borders\");\n    }\n    propKeys.forEach((propKey) => {\n      log.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nfunction applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {\n  const strokeDashArray = [];\n  const addBorder = (length) => {\n    strokeDashArray.push(length, 0);\n  };\n  const skipBorder = (length) => {\n    strokeDashArray.push(0, length);\n  };\n  if (borders.includes(\"t\")) {\n    log.debug(\"add top border\");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes(\"r\")) {\n    log.debug(\"add right border\");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  if (borders.includes(\"b\")) {\n    log.debug(\"add bottom border\");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes(\"l\")) {\n    log.debug(\"add left border\");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  rect2.attr(\"stroke-dasharray\", strokeDashArray.join(\" \"));\n}\nconst rectWithTitle = (parent, node) => {\n  let classes;\n  if (!node.classes) {\n    classes = \"node default\";\n  } else {\n    classes = \"node \" + node.classes;\n  }\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", classes).attr(\"id\", node.domId || node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const innerLine = shapeSvg.insert(\"line\");\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"label\");\n  const text2 = node.labelText.flat ? node.labelText.flat() : node.labelText;\n  let title = \"\";\n  if (typeof text2 === \"object\") {\n    title = text2[0];\n  } else {\n    title = text2;\n  }\n  log.info(\"Label text abc79\", title, text2, typeof text2 === \"object\");\n  const text = label.node().appendChild(createLabel$1(title, node.labelStyle, true, true));\n  let bbox = { width: 0, height: 0 };\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  log.info(\"Text 2\", text2);\n  const textRows = text2.slice(1, text2.length);\n  let titleBox = text.getBBox();\n  const descr = label.node().appendChild(\n    createLabel$1(textRows.join ? textRows.join(\"<br/>\") : textRows, node.labelStyle, true, true)\n  );\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = descr.children[0];\n    const dv = select(descr);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  const halfPadding = node.padding / 2;\n  select(descr).attr(\n    \"transform\",\n    \"translate( \" + // (titleBox.width - bbox.width) / 2 +\n    (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + \", \" + (titleBox.height + halfPadding + 5) + \")\"\n  );\n  select(text).attr(\n    \"transform\",\n    \"translate( \" + // (titleBox.width - bbox.width) / 2 +\n    (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + \", 0)\"\n  );\n  bbox = label.node().getBBox();\n  label.attr(\n    \"transform\",\n    \"translate(\" + -bbox.width / 2 + \", \" + (-bbox.height / 2 - halfPadding + 3) + \")\"\n  );\n  rect2.attr(\"class\", \"outer title-state\").attr(\"x\", -bbox.width / 2 - halfPadding).attr(\"y\", -bbox.height / 2 - halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  innerLine.attr(\"class\", \"divider\").attr(\"x1\", -bbox.width / 2 - halfPadding).attr(\"x2\", bbox.width / 2 + halfPadding).attr(\"y1\", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr(\"y2\", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst stadium = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const h = bbox.height + node.padding;\n  const w = bbox.width + h / 4 + node.padding;\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\").attr(\"style\", node.style).attr(\"rx\", h / 2).attr(\"ry\", h / 2).attr(\"x\", -w / 2).attr(\"y\", -h / 2).attr(\"width\", w).attr(\"height\", h);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst circle = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const circle2 = shapeSvg.insert(\"circle\", \":first-child\");\n  circle2.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"r\", bbox.width / 2 + halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  log.info(\"Circle main\");\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    log.info(\"Circle intersect\", node, bbox.width / 2 + halfPadding, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding, point2);\n  };\n  return shapeSvg;\n};\nconst doublecircle = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const gap = 5;\n  const circleGroup = shapeSvg.insert(\"g\", \":first-child\");\n  const outerCircle = circleGroup.insert(\"circle\");\n  const innerCircle = circleGroup.insert(\"circle\");\n  circleGroup.attr(\"class\", node.class);\n  outerCircle.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"r\", bbox.width / 2 + halfPadding + gap).attr(\"width\", bbox.width + node.padding + gap * 2).attr(\"height\", bbox.height + node.padding + gap * 2);\n  innerCircle.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"r\", bbox.width / 2 + halfPadding).attr(\"width\", bbox.width + node.padding).attr(\"height\", bbox.height + node.padding);\n  log.info(\"DoubleCircle main\");\n  updateNodeBounds(node, outerCircle);\n  node.intersect = function(point2) {\n    log.info(\"DoubleCircle intersect\", node, bbox.width / 2 + halfPadding + gap, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding + gap, point2);\n  };\n  return shapeSvg;\n};\nconst subroutine = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 0, y: 0 },\n    { x: w, y: 0 },\n    { x: w, y: -h },\n    { x: 0, y: -h },\n    { x: 0, y: 0 },\n    { x: -8, y: 0 },\n    { x: w + 8, y: 0 },\n    { x: w + 8, y: -h },\n    { x: -8, y: -h },\n    { x: -8, y: 0 }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr(\"style\", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst start = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  const circle2 = shapeSvg.insert(\"circle\", \":first-child\");\n  circle2.attr(\"class\", \"state-start\").attr(\"r\", 7).attr(\"width\", 14).attr(\"height\", 14);\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst forkJoin = (parent, node, dir) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  let width = 70;\n  let height = 10;\n  if (dir === \"LR\") {\n    width = 10;\n    height = 70;\n  }\n  const shape = shapeSvg.append(\"rect\").attr(\"x\", -1 * width / 2).attr(\"y\", -1 * height / 2).attr(\"width\", width).attr(\"height\", height).attr(\"class\", \"fork-join\");\n  updateNodeBounds(node, shape);\n  node.height = node.height + node.padding / 2;\n  node.width = node.width + node.padding / 2;\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst end = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"node default\").attr(\"id\", node.domId || node.id);\n  const innerCircle = shapeSvg.insert(\"circle\", \":first-child\");\n  const circle2 = shapeSvg.insert(\"circle\", \":first-child\");\n  circle2.attr(\"class\", \"state-start\").attr(\"r\", 7).attr(\"width\", 14).attr(\"height\", 14);\n  innerCircle.attr(\"class\", \"state-end\").attr(\"r\", 5).attr(\"width\", 10).attr(\"height\", 10);\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst class_box = (parent, node) => {\n  const halfPadding = node.padding / 2;\n  const rowPadding = 4;\n  const lineHeight = 8;\n  let classes;\n  if (!node.classes) {\n    classes = \"node default\";\n  } else {\n    classes = \"node \" + node.classes;\n  }\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", classes).attr(\"id\", node.domId || node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const topLine = shapeSvg.insert(\"line\");\n  const bottomLine = shapeSvg.insert(\"line\");\n  let maxWidth = 0;\n  let maxHeight = rowPadding;\n  const labelContainer = shapeSvg.insert(\"g\").attr(\"class\", \"label\");\n  let verticalPos = 0;\n  const hasInterface = node.classData.annotations && node.classData.annotations[0];\n  const interfaceLabelText = node.classData.annotations[0] ? \"«\" + node.classData.annotations[0] + \"»\" : \"\";\n  const interfaceLabel = labelContainer.node().appendChild(createLabel$1(interfaceLabelText, node.labelStyle, true, true));\n  let interfaceBBox = interfaceLabel.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = interfaceLabel.children[0];\n    const dv = select(interfaceLabel);\n    interfaceBBox = div.getBoundingClientRect();\n    dv.attr(\"width\", interfaceBBox.width);\n    dv.attr(\"height\", interfaceBBox.height);\n  }\n  if (node.classData.annotations[0]) {\n    maxHeight += interfaceBBox.height + rowPadding;\n    maxWidth += interfaceBBox.width;\n  }\n  let classTitleString = node.classData.label;\n  if (node.classData.type !== void 0 && node.classData.type !== \"\") {\n    if (getConfig().flowchart.htmlLabels) {\n      classTitleString += \"&lt;\" + node.classData.type + \"&gt;\";\n    } else {\n      classTitleString += \"<\" + node.classData.type + \">\";\n    }\n  }\n  const classTitleLabel = labelContainer.node().appendChild(createLabel$1(classTitleString, node.labelStyle, true, true));\n  select(classTitleLabel).attr(\"class\", \"classTitle\");\n  let classTitleBBox = classTitleLabel.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = classTitleLabel.children[0];\n    const dv = select(classTitleLabel);\n    classTitleBBox = div.getBoundingClientRect();\n    dv.attr(\"width\", classTitleBBox.width);\n    dv.attr(\"height\", classTitleBBox.height);\n  }\n  maxHeight += classTitleBBox.height + rowPadding;\n  if (classTitleBBox.width > maxWidth) {\n    maxWidth = classTitleBBox.width;\n  }\n  const classAttributes = [];\n  node.classData.members.forEach((member) => {\n    const parsedInfo = member.getDisplayDetails();\n    let parsedText = parsedInfo.displayText;\n    if (getConfig().flowchart.htmlLabels) {\n      parsedText = parsedText.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    const lbl = labelContainer.node().appendChild(\n      createLabel$1(\n        parsedText,\n        parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle,\n        true,\n        true\n      )\n    );\n    let bbox = lbl.getBBox();\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = select(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr(\"width\", bbox.width);\n      dv.attr(\"height\", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classAttributes.push(lbl);\n  });\n  maxHeight += lineHeight;\n  const classMethods = [];\n  node.classData.methods.forEach((member) => {\n    const parsedInfo = member.getDisplayDetails();\n    let displayText = parsedInfo.displayText;\n    if (getConfig().flowchart.htmlLabels) {\n      displayText = displayText.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    const lbl = labelContainer.node().appendChild(\n      createLabel$1(\n        displayText,\n        parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle,\n        true,\n        true\n      )\n    );\n    let bbox = lbl.getBBox();\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = select(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr(\"width\", bbox.width);\n      dv.attr(\"height\", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classMethods.push(lbl);\n  });\n  maxHeight += lineHeight;\n  if (hasInterface) {\n    let diffX2 = (maxWidth - interfaceBBox.width) / 2;\n    select(interfaceLabel).attr(\n      \"transform\",\n      \"translate( \" + (-1 * maxWidth / 2 + diffX2) + \", \" + -1 * maxHeight / 2 + \")\"\n    );\n    verticalPos = interfaceBBox.height + rowPadding;\n  }\n  let diffX = (maxWidth - classTitleBBox.width) / 2;\n  select(classTitleLabel).attr(\n    \"transform\",\n    \"translate( \" + (-1 * maxWidth / 2 + diffX) + \", \" + (-1 * maxHeight / 2 + verticalPos) + \")\"\n  );\n  verticalPos += classTitleBBox.height + rowPadding;\n  topLine.attr(\"class\", \"divider\").attr(\"x1\", -maxWidth / 2 - halfPadding).attr(\"x2\", maxWidth / 2 + halfPadding).attr(\"y1\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr(\"y2\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classAttributes.forEach((lbl) => {\n    select(lbl).attr(\n      \"transform\",\n      \"translate( \" + -maxWidth / 2 + \", \" + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + \")\"\n    );\n    const memberBBox = lbl == null ? void 0 : lbl.getBBox();\n    verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;\n  });\n  verticalPos += lineHeight;\n  bottomLine.attr(\"class\", \"divider\").attr(\"x1\", -maxWidth / 2 - halfPadding).attr(\"x2\", maxWidth / 2 + halfPadding).attr(\"y1\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr(\"y2\", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classMethods.forEach((lbl) => {\n    select(lbl).attr(\n      \"transform\",\n      \"translate( \" + -maxWidth / 2 + \", \" + (-1 * maxHeight / 2 + verticalPos) + \")\"\n    );\n    const memberBBox = lbl == null ? void 0 : lbl.getBBox();\n    verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;\n  });\n  rect2.attr(\"style\", node.style).attr(\"class\", \"outer title-state\").attr(\"x\", -maxWidth / 2 - halfPadding).attr(\"y\", -(maxHeight / 2) - halfPadding).attr(\"width\", maxWidth + node.padding).attr(\"height\", maxHeight + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rhombus: question,\n  composite,\n  question,\n  rect,\n  labelRect,\n  rectWithTitle,\n  choice,\n  circle,\n  doublecircle,\n  stadium,\n  hexagon,\n  block_arrow,\n  rect_left_inv_arrow,\n  lean_right,\n  lean_left,\n  trapezoid,\n  inv_trapezoid,\n  rect_right_inv_arrow,\n  cylinder,\n  start,\n  end,\n  note: note$1,\n  subroutine,\n  fork: forkJoin,\n  join: forkJoin,\n  class_box\n};\nlet nodeElems = {};\nconst insertNode = async (elem, node, dir) => {\n  let newEl;\n  let el;\n  if (node.link) {\n    let target;\n    if (getConfig().securityLevel === \"sandbox\") {\n      target = \"_top\";\n    } else if (node.linkTarget) {\n      target = node.linkTarget || \"_blank\";\n    }\n    newEl = elem.insert(\"svg:a\").attr(\"xlink:href\", node.link).attr(\"target\", target);\n    el = await shapes[node.shape](newEl, node, dir);\n  } else {\n    el = await shapes[node.shape](elem, node, dir);\n    newEl = el;\n  }\n  if (node.tooltip) {\n    el.attr(\"title\", node.tooltip);\n  }\n  if (node.class) {\n    el.attr(\"class\", \"node default \" + node.class);\n  }\n  newEl.attr(\"data-node\", \"true\");\n  newEl.attr(\"data-id\", node.id);\n  nodeElems[node.id] = newEl;\n  if (node.haveCallback) {\n    nodeElems[node.id].attr(\"class\", nodeElems[node.id].attr(\"class\") + \" clickable\");\n  }\n  return newEl;\n};\nconst setNodeElem = (elem, node) => {\n  nodeElems[node.id] = elem;\n};\nconst clear$1 = () => {\n  nodeElems = {};\n};\nconst positionNode = (node) => {\n  const el = nodeElems[node.id];\n  log.trace(\n    \"Transforming node\",\n    node.diff,\n    node,\n    \"translate(\" + (node.x - node.width / 2 - 5) + \", \" + node.width / 2 + \")\"\n  );\n  const padding = 8;\n  const diff = node.diff || 0;\n  if (node.clusterNode) {\n    el.attr(\n      \"transform\",\n      \"translate(\" + (node.x + diff - node.width / 2) + \", \" + (node.y - node.height / 2 - padding) + \")\"\n    );\n  } else {\n    el.attr(\"transform\", \"translate(\" + node.x + \", \" + node.y + \")\");\n  }\n  return diff;\n};\nconst getSubGraphTitleMargins = ({\n  flowchart\n}) => {\n  var _a, _b;\n  const subGraphTitleTopMargin = ((_a = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _a.top) ?? 0;\n  const subGraphTitleBottomMargin = ((_b = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _b.bottom) ?? 0;\n  const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;\n  return {\n    subGraphTitleTopMargin,\n    subGraphTitleBottomMargin,\n    subGraphTitleTotalMargin\n  };\n};\nconst markerOffsets = {\n  aggregation: 18,\n  extension: 18,\n  composition: 18,\n  dependency: 6,\n  lollipop: 13.5,\n  arrow_point: 5.3\n};\nfunction calculateDeltaAndAngle(point1, point2) {\n  if (point1 === void 0 || point2 === void 0) {\n    return { angle: 0, deltaX: 0, deltaY: 0 };\n  }\n  point1 = pointTransformer(point1);\n  point2 = pointTransformer(point2);\n  const [x1, y1] = [point1.x, point1.y];\n  const [x2, y2] = [point2.x, point2.y];\n  const deltaX = x2 - x1;\n  const deltaY = y2 - y1;\n  return { angle: Math.atan(deltaY / deltaX), deltaX, deltaY };\n}\nconst pointTransformer = (data) => {\n  if (Array.isArray(data)) {\n    return { x: data[0], y: data[1] };\n  }\n  return data;\n};\nconst getLineFunctionsWithOffset = (edge) => {\n  return {\n    x: function(d, i, data) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaX } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).x + offset;\n    },\n    y: function(d, i, data) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).y + offset;\n    }\n  };\n};\nconst addEdgeMarkers = (svgPath, edge, url, id, diagramType) => {\n  if (edge.arrowTypeStart) {\n    addEdgeMarker(svgPath, \"start\", edge.arrowTypeStart, url, id, diagramType);\n  }\n  if (edge.arrowTypeEnd) {\n    addEdgeMarker(svgPath, \"end\", edge.arrowTypeEnd, url, id, diagramType);\n  }\n};\nconst arrowTypesMap = {\n  arrow_cross: \"cross\",\n  arrow_point: \"point\",\n  arrow_barb: \"barb\",\n  arrow_circle: \"circle\",\n  aggregation: \"aggregation\",\n  extension: \"extension\",\n  composition: \"composition\",\n  dependency: \"dependency\",\n  lollipop: \"lollipop\"\n};\nconst addEdgeMarker = (svgPath, position, arrowType, url, id, diagramType) => {\n  const endMarkerType = arrowTypesMap[arrowType];\n  if (!endMarkerType) {\n    log.warn(`Unknown arrow type: ${arrowType}`);\n    return;\n  }\n  const suffix = position === \"start\" ? \"Start\" : \"End\";\n  svgPath.attr(`marker-${position}`, `url(${url}#${id}_${diagramType}-${endMarkerType}${suffix})`);\n};\nlet edgeLabels = {};\nlet terminalLabels = {};\nconst clear = () => {\n  edgeLabels = {};\n  terminalLabels = {};\n};\nconst insertEdgeLabel = (elem, edge) => {\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n  const labelElement = edge.labelType === \"markdown\" ? createText(elem, edge.label, {\n    style: edge.labelStyle,\n    useHtmlLabels,\n    addSvgBackground: true\n  }) : createLabel$1(edge.label, edge.labelStyle);\n  const edgeLabel = elem.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const label = edgeLabel.insert(\"g\").attr(\"class\", \"label\");\n  label.node().appendChild(labelElement);\n  let bbox = labelElement.getBBox();\n  if (useHtmlLabels) {\n    const div = labelElement.children[0];\n    const dv = select(labelElement);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  label.attr(\"transform\", \"translate(\" + -bbox.width / 2 + \", \" + -bbox.height / 2 + \")\");\n  edgeLabels[edge.id] = edgeLabel;\n  edge.width = bbox.width;\n  edge.height = bbox.height;\n  let fo;\n  if (edge.startLabelLeft) {\n    const startLabelElement = createLabel$1(edge.startLabelLeft, edge.labelStyle);\n    const startEdgeLabelLeft = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = startEdgeLabelLeft.insert(\"g\").attr(\"class\", \"inner\");\n    fo = inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;\n    setTerminalWidth(fo, edge.startLabelLeft);\n  }\n  if (edge.startLabelRight) {\n    const startLabelElement = createLabel$1(edge.startLabelRight, edge.labelStyle);\n    const startEdgeLabelRight = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = startEdgeLabelRight.insert(\"g\").attr(\"class\", \"inner\");\n    fo = startEdgeLabelRight.node().appendChild(startLabelElement);\n    inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startRight = startEdgeLabelRight;\n    setTerminalWidth(fo, edge.startLabelRight);\n  }\n  if (edge.endLabelLeft) {\n    const endLabelElement = createLabel$1(edge.endLabelLeft, edge.labelStyle);\n    const endEdgeLabelLeft = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = endEdgeLabelLeft.insert(\"g\").attr(\"class\", \"inner\");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    endEdgeLabelLeft.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;\n    setTerminalWidth(fo, edge.endLabelLeft);\n  }\n  if (edge.endLabelRight) {\n    const endLabelElement = createLabel$1(edge.endLabelRight, edge.labelStyle);\n    const endEdgeLabelRight = elem.insert(\"g\").attr(\"class\", \"edgeTerminals\");\n    const inner = endEdgeLabelRight.insert(\"g\").attr(\"class\", \"inner\");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr(\"transform\", \"translate(\" + -slBox.width / 2 + \", \" + -slBox.height / 2 + \")\");\n    endEdgeLabelRight.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endRight = endEdgeLabelRight;\n    setTerminalWidth(fo, edge.endLabelRight);\n  }\n  return labelElement;\n};\nfunction setTerminalWidth(fo, value) {\n  if (getConfig().flowchart.htmlLabels && fo) {\n    fo.style.width = value.length * 9 + \"px\";\n    fo.style.height = \"12px\";\n  }\n}\nconst positionEdgeLabel = (edge, paths) => {\n  log.debug(\"Moving label abc88 \", edge.id, edge.label, edgeLabels[edge.id], paths);\n  let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;\n  const siteConfig = getConfig();\n  const { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);\n  if (edge.label) {\n    const el = edgeLabels[edge.id];\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcLabelPosition(path);\n      log.debug(\n        \"Moving label \" + edge.label + \" from (\",\n        x,\n        \",\",\n        y,\n        \") to (\",\n        pos.x,\n        \",\",\n        pos.y,\n        \") abc88\"\n      );\n      if (paths.updatedPath) {\n        x = pos.x;\n        y = pos.y;\n      }\n    }\n    el.attr(\"transform\", `translate(${x}, ${y + subGraphTitleTotalMargin / 2})`);\n  }\n  if (edge.startLabelLeft) {\n    const el = terminalLabels[edge.id].startLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, \"start_left\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n  if (edge.startLabelRight) {\n    const el = terminalLabels[edge.id].startRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(\n        edge.arrowTypeStart ? 10 : 0,\n        \"start_right\",\n        path\n      );\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n  if (edge.endLabelLeft) {\n    const el = terminalLabels[edge.id].endLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, \"end_left\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n  if (edge.endLabelRight) {\n    const el = terminalLabels[edge.id].endRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, \"end_right\", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr(\"transform\", `translate(${x}, ${y})`);\n  }\n};\nconst outsideNode = (node, point2) => {\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(point2.x - x);\n  const dy = Math.abs(point2.y - y);\n  const w = node.width / 2;\n  const h = node.height / 2;\n  if (dx >= w || dy >= h) {\n    return true;\n  }\n  return false;\n};\nconst intersection = (node, outsidePoint, insidePoint) => {\n  log.debug(`intersection calc abc89:\n  outsidePoint: ${JSON.stringify(outsidePoint)}\n  insidePoint : ${JSON.stringify(insidePoint)}\n  node        : x:${node.x} y:${node.y} w:${node.width} h:${node.height}`);\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(x - insidePoint.x);\n  const w = node.width / 2;\n  let r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;\n  const h = node.height / 2;\n  const Q = Math.abs(outsidePoint.y - insidePoint.y);\n  const R = Math.abs(outsidePoint.x - insidePoint.x);\n  if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {\n    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;\n    r = R * q / Q;\n    const res = {\n      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,\n      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q\n    };\n    if (r === 0) {\n      res.x = outsidePoint.x;\n      res.y = outsidePoint.y;\n    }\n    if (R === 0) {\n      res.x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      res.y = outsidePoint.y;\n    }\n    log.debug(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);\n    return res;\n  } else {\n    if (insidePoint.x < outsidePoint.x) {\n      r = outsidePoint.x - w - x;\n    } else {\n      r = x - w - outsidePoint.x;\n    }\n    let q = Q * r / R;\n    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;\n    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;\n    log.debug(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });\n    if (r === 0) {\n      _x = outsidePoint.x;\n      _y = outsidePoint.y;\n    }\n    if (R === 0) {\n      _x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      _y = outsidePoint.y;\n    }\n    return { x: _x, y: _y };\n  }\n};\nconst cutPathAtIntersect = (_points, boundaryNode) => {\n  log.debug(\"abc88 cutPathAtIntersect\", _points, boundaryNode);\n  let points = [];\n  let lastPointOutside = _points[0];\n  let isInside = false;\n  _points.forEach((point2) => {\n    if (!outsideNode(boundaryNode, point2) && !isInside) {\n      const inter = intersection(boundaryNode, lastPointOutside, point2);\n      let pointPresent = false;\n      points.forEach((p) => {\n        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;\n      });\n      if (!points.some((e) => e.x === inter.x && e.y === inter.y)) {\n        points.push(inter);\n      }\n      isInside = true;\n    } else {\n      lastPointOutside = point2;\n      if (!isInside) {\n        points.push(point2);\n      }\n    }\n  });\n  return points;\n};\nconst insertEdge = function(elem, e, edge, clusterDb, diagramType, graph, id) {\n  let points = edge.points;\n  log.debug(\"abc88 InsertEdge: edge=\", edge, \"e=\", e);\n  let pointsHasChanged = false;\n  const tail = graph.node(e.v);\n  var head = graph.node(e.w);\n  if ((head == null ? void 0 : head.intersect) && (tail == null ? void 0 : tail.intersect)) {\n    points = points.slice(1, edge.points.length - 1);\n    points.unshift(tail.intersect(points[0]));\n    points.push(head.intersect(points[points.length - 1]));\n  }\n  if (edge.toCluster) {\n    log.debug(\"to cluster abc88\", clusterDb[edge.toCluster]);\n    points = cutPathAtIntersect(edge.points, clusterDb[edge.toCluster].node);\n    pointsHasChanged = true;\n  }\n  if (edge.fromCluster) {\n    log.debug(\"from cluster abc88\", clusterDb[edge.fromCluster]);\n    points = cutPathAtIntersect(points.reverse(), clusterDb[edge.fromCluster].node).reverse();\n    pointsHasChanged = true;\n  }\n  const lineData = points.filter((p) => !Number.isNaN(p.y));\n  let curve = curveBasis;\n  if (edge.curve && (diagramType === \"graph\" || diagramType === \"flowchart\")) {\n    curve = edge.curve;\n  }\n  const { x, y } = getLineFunctionsWithOffset(edge);\n  const lineFunction = line().x(x).y(y).curve(curve);\n  let strokeClasses;\n  switch (edge.thickness) {\n    case \"normal\":\n      strokeClasses = \"edge-thickness-normal\";\n      break;\n    case \"thick\":\n      strokeClasses = \"edge-thickness-thick\";\n      break;\n    case \"invisible\":\n      strokeClasses = \"edge-thickness-thick\";\n      break;\n    default:\n      strokeClasses = \"\";\n  }\n  switch (edge.pattern) {\n    case \"solid\":\n      strokeClasses += \" edge-pattern-solid\";\n      break;\n    case \"dotted\":\n      strokeClasses += \" edge-pattern-dotted\";\n      break;\n    case \"dashed\":\n      strokeClasses += \" edge-pattern-dashed\";\n      break;\n  }\n  const svgPath = elem.append(\"path\").attr(\"d\", lineFunction(lineData)).attr(\"id\", edge.id).attr(\"class\", \" \" + strokeClasses + (edge.classes ? \" \" + edge.classes : \"\")).attr(\"style\", edge.style);\n  let url = \"\";\n  if (getConfig().flowchart.arrowMarkerAbsolute || getConfig().state.arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n  addEdgeMarkers(svgPath, edge, url, id, diagramType);\n  let paths = {};\n  if (pointsHasChanged) {\n    paths.updatedPath = points;\n  }\n  paths.originalPath = edge.points;\n  return paths;\n};\nexport {\n  insertMarkers$1 as a,\n  clear$1 as b,\n  createLabel$1 as c,\n  clear as d,\n  insertNode as e,\n  insertEdgeLabel as f,\n  getSubGraphTitleMargins as g,\n  insertEdge as h,\n  intersectRect$1 as i,\n  positionEdgeLabel as j,\n  getLineFunctionsWithOffset as k,\n  labelHelper as l,\n  addEdgeMarkers as m,\n  positionNode as p,\n  setNodeElem as s,\n  updateNodeBounds as u\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}