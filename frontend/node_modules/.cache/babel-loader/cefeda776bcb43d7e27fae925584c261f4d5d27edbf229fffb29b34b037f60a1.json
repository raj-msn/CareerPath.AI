{"ast":null,"code":"import * as _ from 'lodash-es';\nexport { PriorityQueue };\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nclass PriorityQueue {\n  constructor() {\n    this._arr = [];\n    this._keyIndices = {};\n  }\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return this._arr.length;\n  }\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return this._arr.map(function (x) {\n      return x.key;\n    });\n  }\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return _.has(this._keyIndices, key);\n  }\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n  priority(key) {\n    var index = this._keyIndices[key];\n    if (index !== undefined) {\n      return this._arr[index].priority;\n    }\n  }\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if (this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n    return this._arr[0].key;\n  }\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n  add(key, priority) {\n    var keyIndices = this._keyIndices;\n    key = String(key);\n    if (!_.has(keyIndices, key)) {\n      var arr = this._arr;\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({\n        key: key,\n        priority: priority\n      });\n      this._decrease(index);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    this._swap(0, this._arr.length - 1);\n    var min = this._arr.pop();\n    delete this._keyIndices[min.key];\n    this._heapify(0);\n    return min.key;\n  }\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n  decrease(key, priority) {\n    var index = this._keyIndices[key];\n    if (priority > this._arr[index].priority) {\n      throw new Error('New priority is greater than current priority. ' + 'Key: ' + key + ' Old: ' + this._arr[index].priority + ' New: ' + priority);\n    }\n    this._arr[index].priority = priority;\n    this._decrease(index);\n  }\n  _heapify(i) {\n    var arr = this._arr;\n    var l = 2 * i;\n    var r = l + 1;\n    var largest = i;\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if (largest !== i) {\n        this._swap(i, largest);\n        this._heapify(largest);\n      }\n    }\n  }\n  _decrease(index) {\n    var arr = this._arr;\n    var priority = arr[index].priority;\n    var parent;\n    while (index !== 0) {\n      parent = index >> 1;\n      if (arr[parent].priority < priority) {\n        break;\n      }\n      this._swap(index, parent);\n      index = parent;\n    }\n  }\n  _swap(i, j) {\n    var arr = this._arr;\n    var keyIndices = this._keyIndices;\n    var origArrI = arr[i];\n    var origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices[origArrJ.key] = i;\n    keyIndices[origArrI.key] = j;\n  }\n}","map":{"version":3,"names":["_","PriorityQueue","constructor","_arr","_keyIndices","size","length","keys","map","x","key","has","priority","index","undefined","min","Error","add","keyIndices","String","arr","push","_decrease","removeMin","_swap","pop","_heapify","decrease","i","l","r","largest","parent","j","origArrI","origArrJ"],"sources":["/Users/anasshaik/Desktop/Projects/CareerPath.AI/frontend/node_modules/dagre-d3-es/src/graphlib/data/priority-queue.js"],"sourcesContent":["import * as _ from 'lodash-es';\n\nexport { PriorityQueue };\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nclass PriorityQueue {\n  constructor() {\n    this._arr = [];\n    this._keyIndices = {};\n  }\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return this._arr.length;\n  }\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return this._arr.map(function (x) {\n      return x.key;\n    });\n  }\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return _.has(this._keyIndices, key);\n  }\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n  priority(key) {\n    var index = this._keyIndices[key];\n    if (index !== undefined) {\n      return this._arr[index].priority;\n    }\n  }\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if (this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n    return this._arr[0].key;\n  }\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n  add(key, priority) {\n    var keyIndices = this._keyIndices;\n    key = String(key);\n    if (!_.has(keyIndices, key)) {\n      var arr = this._arr;\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({ key: key, priority: priority });\n      this._decrease(index);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    this._swap(0, this._arr.length - 1);\n    var min = this._arr.pop();\n    delete this._keyIndices[min.key];\n    this._heapify(0);\n    return min.key;\n  }\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n  decrease(key, priority) {\n    var index = this._keyIndices[key];\n    if (priority > this._arr[index].priority) {\n      throw new Error(\n        'New priority is greater than current priority. ' +\n          'Key: ' +\n          key +\n          ' Old: ' +\n          this._arr[index].priority +\n          ' New: ' +\n          priority\n      );\n    }\n    this._arr[index].priority = priority;\n    this._decrease(index);\n  }\n  _heapify(i) {\n    var arr = this._arr;\n    var l = 2 * i;\n    var r = l + 1;\n    var largest = i;\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if (largest !== i) {\n        this._swap(i, largest);\n        this._heapify(largest);\n      }\n    }\n  }\n  _decrease(index) {\n    var arr = this._arr;\n    var priority = arr[index].priority;\n    var parent;\n    while (index !== 0) {\n      parent = index >> 1;\n      if (arr[parent].priority < priority) {\n        break;\n      }\n      this._swap(index, parent);\n      index = parent;\n    }\n  }\n  _swap(i, j) {\n    var arr = this._arr;\n    var keyIndices = this._keyIndices;\n    var origArrI = arr[i];\n    var origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices[origArrJ.key] = i;\n    keyIndices[origArrI.key] = j;\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,CAAC,MAAM,WAAW;AAE9B,SAASC,aAAa;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,aAAa,CAAC;EAClBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;EACvB;EACA;AACF;AACA;EACEC,IAAIA,CAAA,EAAG;IACL,OAAO,IAAI,CAACF,IAAI,CAACG,MAAM;EACzB;EACA;AACF;AACA;EACEC,IAAIA,CAAA,EAAG;IACL,OAAO,IAAI,CAACJ,IAAI,CAACK,GAAG,CAAC,UAAUC,CAAC,EAAE;MAChC,OAAOA,CAAC,CAACC,GAAG;IACd,CAAC,CAAC;EACJ;EACA;AACF;AACA;EACEC,GAAGA,CAACD,GAAG,EAAE;IACP,OAAOV,CAAC,CAACW,GAAG,CAAC,IAAI,CAACP,WAAW,EAAEM,GAAG,CAAC;EACrC;EACA;AACF;AACA;AACA;AACA;AACA;EACEE,QAAQA,CAACF,GAAG,EAAE;IACZ,IAAIG,KAAK,GAAG,IAAI,CAACT,WAAW,CAACM,GAAG,CAAC;IACjC,IAAIG,KAAK,KAAKC,SAAS,EAAE;MACvB,OAAO,IAAI,CAACX,IAAI,CAACU,KAAK,CAAC,CAACD,QAAQ;IAClC;EACF;EACA;AACF;AACA;AACA;EACEG,GAAGA,CAAA,EAAG;IACJ,IAAI,IAAI,CAACV,IAAI,CAAC,CAAC,KAAK,CAAC,EAAE;MACrB,MAAM,IAAIW,KAAK,CAAC,iBAAiB,CAAC;IACpC;IACA,OAAO,IAAI,CAACb,IAAI,CAAC,CAAC,CAAC,CAACO,GAAG;EACzB;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,GAAGA,CAACP,GAAG,EAAEE,QAAQ,EAAE;IACjB,IAAIM,UAAU,GAAG,IAAI,CAACd,WAAW;IACjCM,GAAG,GAAGS,MAAM,CAACT,GAAG,CAAC;IACjB,IAAI,CAACV,CAAC,CAACW,GAAG,CAACO,UAAU,EAAER,GAAG,CAAC,EAAE;MAC3B,IAAIU,GAAG,GAAG,IAAI,CAACjB,IAAI;MACnB,IAAIU,KAAK,GAAGO,GAAG,CAACd,MAAM;MACtBY,UAAU,CAACR,GAAG,CAAC,GAAGG,KAAK;MACvBO,GAAG,CAACC,IAAI,CAAC;QAAEX,GAAG,EAAEA,GAAG;QAAEE,QAAQ,EAAEA;MAAS,CAAC,CAAC;MAC1C,IAAI,CAACU,SAAS,CAACT,KAAK,CAAC;MACrB,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EACA;AACF;AACA;EACEU,SAASA,CAAA,EAAG;IACV,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,IAAI,CAACrB,IAAI,CAACG,MAAM,GAAG,CAAC,CAAC;IACnC,IAAIS,GAAG,GAAG,IAAI,CAACZ,IAAI,CAACsB,GAAG,CAAC,CAAC;IACzB,OAAO,IAAI,CAACrB,WAAW,CAACW,GAAG,CAACL,GAAG,CAAC;IAChC,IAAI,CAACgB,QAAQ,CAAC,CAAC,CAAC;IAChB,OAAOX,GAAG,CAACL,GAAG;EAChB;EACA;AACF;AACA;AACA;AACA;AACA;AACA;EACEiB,QAAQA,CAACjB,GAAG,EAAEE,QAAQ,EAAE;IACtB,IAAIC,KAAK,GAAG,IAAI,CAACT,WAAW,CAACM,GAAG,CAAC;IACjC,IAAIE,QAAQ,GAAG,IAAI,CAACT,IAAI,CAACU,KAAK,CAAC,CAACD,QAAQ,EAAE;MACxC,MAAM,IAAII,KAAK,CACb,iDAAiD,GAC/C,OAAO,GACPN,GAAG,GACH,QAAQ,GACR,IAAI,CAACP,IAAI,CAACU,KAAK,CAAC,CAACD,QAAQ,GACzB,QAAQ,GACRA,QACJ,CAAC;IACH;IACA,IAAI,CAACT,IAAI,CAACU,KAAK,CAAC,CAACD,QAAQ,GAAGA,QAAQ;IACpC,IAAI,CAACU,SAAS,CAACT,KAAK,CAAC;EACvB;EACAa,QAAQA,CAACE,CAAC,EAAE;IACV,IAAIR,GAAG,GAAG,IAAI,CAACjB,IAAI;IACnB,IAAI0B,CAAC,GAAG,CAAC,GAAGD,CAAC;IACb,IAAIE,CAAC,GAAGD,CAAC,GAAG,CAAC;IACb,IAAIE,OAAO,GAAGH,CAAC;IACf,IAAIC,CAAC,GAAGT,GAAG,CAACd,MAAM,EAAE;MAClByB,OAAO,GAAGX,GAAG,CAACS,CAAC,CAAC,CAACjB,QAAQ,GAAGQ,GAAG,CAACW,OAAO,CAAC,CAACnB,QAAQ,GAAGiB,CAAC,GAAGE,OAAO;MAC/D,IAAID,CAAC,GAAGV,GAAG,CAACd,MAAM,EAAE;QAClByB,OAAO,GAAGX,GAAG,CAACU,CAAC,CAAC,CAAClB,QAAQ,GAAGQ,GAAG,CAACW,OAAO,CAAC,CAACnB,QAAQ,GAAGkB,CAAC,GAAGC,OAAO;MACjE;MACA,IAAIA,OAAO,KAAKH,CAAC,EAAE;QACjB,IAAI,CAACJ,KAAK,CAACI,CAAC,EAAEG,OAAO,CAAC;QACtB,IAAI,CAACL,QAAQ,CAACK,OAAO,CAAC;MACxB;IACF;EACF;EACAT,SAASA,CAACT,KAAK,EAAE;IACf,IAAIO,GAAG,GAAG,IAAI,CAACjB,IAAI;IACnB,IAAIS,QAAQ,GAAGQ,GAAG,CAACP,KAAK,CAAC,CAACD,QAAQ;IAClC,IAAIoB,MAAM;IACV,OAAOnB,KAAK,KAAK,CAAC,EAAE;MAClBmB,MAAM,GAAGnB,KAAK,IAAI,CAAC;MACnB,IAAIO,GAAG,CAACY,MAAM,CAAC,CAACpB,QAAQ,GAAGA,QAAQ,EAAE;QACnC;MACF;MACA,IAAI,CAACY,KAAK,CAACX,KAAK,EAAEmB,MAAM,CAAC;MACzBnB,KAAK,GAAGmB,MAAM;IAChB;EACF;EACAR,KAAKA,CAACI,CAAC,EAAEK,CAAC,EAAE;IACV,IAAIb,GAAG,GAAG,IAAI,CAACjB,IAAI;IACnB,IAAIe,UAAU,GAAG,IAAI,CAACd,WAAW;IACjC,IAAI8B,QAAQ,GAAGd,GAAG,CAACQ,CAAC,CAAC;IACrB,IAAIO,QAAQ,GAAGf,GAAG,CAACa,CAAC,CAAC;IACrBb,GAAG,CAACQ,CAAC,CAAC,GAAGO,QAAQ;IACjBf,GAAG,CAACa,CAAC,CAAC,GAAGC,QAAQ;IACjBhB,UAAU,CAACiB,QAAQ,CAACzB,GAAG,CAAC,GAAGkB,CAAC;IAC5BV,UAAU,CAACgB,QAAQ,CAACxB,GAAG,CAAC,GAAGuB,CAAC;EAC9B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}