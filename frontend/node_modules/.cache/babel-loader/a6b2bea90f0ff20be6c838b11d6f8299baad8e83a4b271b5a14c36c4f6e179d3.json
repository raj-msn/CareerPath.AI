{"ast":null,"code":"import { l as log, M as decodeEntities } from \"./mermaid-b5860b54.js\";\nimport { fromMarkdown } from \"mdast-util-from-markdown\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const {\n    children\n  } = fromMarkdown(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.value.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach(word => {\n          if (word) {\n            lines[currentLine].push({\n              content: word,\n              type: parentType\n            });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"emphasis\") {\n      node.children.forEach(contentNode => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  children.forEach(treeNode => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.children.forEach(contentNode => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const {\n    children\n  } = fromMarkdown(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.value.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.children.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"emphasis\") {\n      return `<em>${node.children.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.children.map(output).join(\"\")}</p>`;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  return children.map(output).join(\"\");\n}\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map(s => s.segment);\n  }\n  return [...text];\n}\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [{\n      content: usedChars.join(\"\"),\n      type\n    }, {\n      content: \"\",\n      type\n    }];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{\n    content: newWord.join(\"\"),\n    type\n  }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [{\n    content: usedChars.join(\"\"),\n    type\n  }, {\n    content: remainingChars.join(\"\"),\n    type\n  }];\n}\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({\n    content\n  }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? {\n    content: \" \",\n    type: \"normal\"\n  };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({\n      content: joiner,\n      type: \"normal\"\n    });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(`\n    <span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\");\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  var _a;\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{\n    content: text,\n    type: \"normal\"\n  }]);\n  const textDimension = (_a = testSpan.node()) == null ? void 0 : _a.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = line2 => computeWidthOfText(labelGroup, lineHeight, line2) <= width;\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"emphasis\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}) => {\n  log.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(/fa[blrs]?:fa-[\\w-]+/g,\n      // cspell: disable-line\n      s => `<i class='${s.replace(\":\", \" \")}'></i>`),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\nexport { createText as a, computeDimensionOfText as c };","map":{"version":3,"names":["l","log","M","decodeEntities","fromMarkdown","dedent","preprocessMarkdown","markdown","withoutMultipleNewlines","replace","withoutExtraSpaces","markdownToLines","preprocessedMarkdown","children","lines","currentLine","processNode","node","parentType","type","textLines","value","split","forEach","textLine","index","push","word","content","contentNode","treeNode","markdownToHTML","output","map","join","splitTextToChars","text","Intl","Segmenter","segment","s","splitWordToFitWidth","checkFit","characters","splitWordToFitWidthRecursion","usedChars","remainingChars","length","nextChar","rest","newWord","shift","splitLineToFitWidth","line","some","includes","Error","splitLineToFitWidthRecursion","words","newLine","joiner","nextWord","lineWithNextWord","unshift","applyStyle","dom","styleFn","attr","addHtmlSpan","element","width","classes","addBackground","fo","append","div","label","labelClass","isNode","html","labelStyle","style","bbox","getBoundingClientRect","height","createTspan","textElement","lineIndex","lineHeight","computeWidthOfText","parentNode","testElement","testSpan","updateTextContentAndStyles","textLength","getComputedTextLength","remove","computeDimensionOfText","_a","textDimension","createFormattedText","g","structuredText","labelGroup","bkg","insert","checkWidth","line2","linesUnderWidth","preparedLine","tspan","getBBox","padding","wrappedLine","innerTspan","createText","el","isTitle","useHtmlLabels","addSvgBackground","info","htmlText","vertexNode","svgLabel","a","c"],"sources":["/Users/anasshaik/Desktop/Projects/CareerPath.AI/frontend/node_modules/mermaid/dist/createText-2e5e7dd3.js"],"sourcesContent":["import { l as log, M as decodeEntities } from \"./mermaid-b5860b54.js\";\nimport { fromMarkdown } from \"mdast-util-from-markdown\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const { children } = fromMarkdown(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.value.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"emphasis\") {\n      node.children.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  children.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.children.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const { children } = fromMarkdown(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.value.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.children.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"emphasis\") {\n      return `<em>${node.children.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.children.map(output).join(\"\")}</p>`;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  return children.map(output).join(\"\");\n}\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    `\n    <span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  var _a;\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = (_a = testSpan.node()) == null ? void 0 : _a.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = (line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width;\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"emphasis\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}) => {\n  log.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        // cspell: disable-line\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\nexport {\n  createText as a,\n  computeDimensionOfText as c\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}