{"ast":null,"code":"import { d as db, p as parser } from \"./flowDb-956e92f1.js\";\nimport { select, curveLinear, line } from \"d3\";\nimport { a as insertMarkers, e as insertNode, l as labelHelper, f as insertEdgeLabel, k as getLineFunctionsWithOffset, m as addEdgeMarkers } from \"./edges-e0da2a9e.js\";\nimport { l as log, F as getConfig, o as setupGraphViewbox, k as getStylesFromArray, n as interpolateToCurve, e as common } from \"./mermaid-b5860b54.js\";\nimport ELK from \"elkjs/lib/elk.bundled.js\";\nimport \"./createText-2e5e7dd3.js\";\nimport \"mdast-util-from-markdown\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nconst findCommonAncestor = (id1, id2, treeData) => {\n  const {\n    parentById\n  } = treeData;\n  const visited = /* @__PURE__ */new Set();\n  let currentId = id1;\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  return \"root\";\n};\nconst elk = new ELK();\nlet portPos = {};\nconst conf = {};\nlet nodeDb = {};\nconst addVertices = async function (vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert(\"g\").attr(\"class\", \"nodes\");\n  const keys = Object.keys(vert);\n  await Promise.all(keys.map(async function (id) {\n    const vertex = vert[id];\n    let classStr = \"default\";\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(\" \");\n    }\n    classStr = classStr + \" flowchart-label\";\n    const styles2 = getStylesFromArray(vertex.styles);\n    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n    const labelData = {\n      width: 0,\n      height: 0\n    };\n    const ports = [{\n      id: vertex.id + \"-west\",\n      layoutOptions: {\n        \"port.side\": \"WEST\"\n      }\n    }, {\n      id: vertex.id + \"-east\",\n      layoutOptions: {\n        \"port.side\": \"EAST\"\n      }\n    }, {\n      id: vertex.id + \"-south\",\n      layoutOptions: {\n        \"port.side\": \"SOUTH\"\n      }\n    }, {\n      id: vertex.id + \"-north\",\n      layoutOptions: {\n        \"port.side\": \"NORTH\"\n      }\n    }];\n    let radius = 0;\n    let _shape = \"\";\n    let layoutOptions = {};\n    switch (vertex.type) {\n      case \"round\":\n        radius = 5;\n        _shape = \"rect\";\n        break;\n      case \"square\":\n        _shape = \"rect\";\n        break;\n      case \"diamond\":\n        _shape = \"question\";\n        layoutOptions = {\n          portConstraints: \"FIXED_SIDE\"\n        };\n        break;\n      case \"hexagon\":\n        _shape = \"hexagon\";\n        break;\n      case \"odd\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n      case \"lean_right\":\n        _shape = \"lean_right\";\n        break;\n      case \"lean_left\":\n        _shape = \"lean_left\";\n        break;\n      case \"trapezoid\":\n        _shape = \"trapezoid\";\n        break;\n      case \"inv_trapezoid\":\n        _shape = \"inv_trapezoid\";\n        break;\n      case \"odd_right\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n      case \"circle\":\n        _shape = \"circle\";\n        break;\n      case \"ellipse\":\n        _shape = \"ellipse\";\n        break;\n      case \"stadium\":\n        _shape = \"stadium\";\n        break;\n      case \"subroutine\":\n        _shape = \"subroutine\";\n        break;\n      case \"cylinder\":\n        _shape = \"cylinder\";\n        break;\n      case \"group\":\n        _shape = \"rect\";\n        break;\n      case \"doublecircle\":\n        _shape = \"doublecircle\";\n        break;\n      default:\n        _shape = \"rect\";\n    }\n    const node = {\n      labelStyle: styles2.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      labelType: vertex.labelType,\n      rx: radius,\n      ry: radius,\n      class: classStr,\n      style: styles2.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || \"\",\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === \"group\" ? 500 : void 0,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding\n    };\n    let boundingBox;\n    let nodeEl;\n    if (node.type !== \"group\") {\n      nodeEl = await insertNode(nodes, node, vertex.dir);\n      boundingBox = nodeEl.node().getBBox();\n    } else {\n      doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      const {\n        shapeSvg,\n        bbox\n      } = await labelHelper(nodes, node, void 0, true);\n      labelData.width = bbox.width;\n      labelData.wrappingWidth = getConfig().flowchart.wrappingWidth;\n      labelData.height = bbox.height;\n      labelData.labelNode = shapeSvg.node();\n      node.labelData = labelData;\n    }\n    const data = {\n      id: vertex.id,\n      ports: vertex.type === \"diamond\" ? ports : [],\n      // labelStyle: styles.labelStyle,\n      // shape: _shape,\n      layoutOptions,\n      labelText: vertexText,\n      labelData,\n      // labels: [{ text: vertexText }],\n      // rx: radius,\n      // ry: radius,\n      // class: classStr,\n      // style: styles.style,\n      // link: vertex.link,\n      // linkTarget: vertex.linkTarget,\n      // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      // haveCallback: vertex.haveCallback,\n      width: boundingBox == null ? void 0 : boundingBox.width,\n      height: boundingBox == null ? void 0 : boundingBox.height,\n      // dir: vertex.dir,\n      type: vertex.type,\n      // props: vertex.props,\n      // padding: getConfig().flowchart.padding,\n      // boundingBox,\n      el: nodeEl,\n      parent: parentLookupDb.parentById[vertex.id]\n    };\n    nodeDb[node.id] = data;\n  }));\n  return graph;\n};\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos2 = {\n    TB: {\n      in: {\n        north: \"north\"\n      },\n      out: {\n        south: \"west\",\n        west: \"east\",\n        east: \"south\"\n      }\n    },\n    LR: {\n      in: {\n        west: \"west\"\n      },\n      out: {\n        east: \"south\",\n        south: \"north\",\n        north: \"east\"\n      }\n    },\n    RL: {\n      in: {\n        east: \"east\"\n      },\n      out: {\n        west: \"north\",\n        north: \"south\",\n        south: \"west\"\n      }\n    },\n    BT: {\n      in: {\n        south: \"south\"\n      },\n      out: {\n        north: \"east\",\n        east: \"west\",\n        west: \"north\"\n      }\n    }\n  };\n  portPos2.TD = portPos2.TB;\n  return portPos2[graphDirection][edgeDirection][position];\n};\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info(\"getNextPort\", {\n    node,\n    edgeDirection,\n    graphDirection\n  });\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case \"TB\":\n      case \"TD\":\n        portPos[node] = {\n          inPosition: \"north\",\n          outPosition: \"south\"\n        };\n        break;\n      case \"BT\":\n        portPos[node] = {\n          inPosition: \"south\",\n          outPosition: \"north\"\n        };\n        break;\n      case \"RL\":\n        portPos[node] = {\n          inPosition: \"east\",\n          outPosition: \"west\"\n        };\n        break;\n      case \"LR\":\n        portPos[node] = {\n          inPosition: \"west\",\n          outPosition: \"east\"\n        };\n        break;\n    }\n  }\n  const result = edgeDirection === \"in\" ? portPos[node].inPosition : portPos[node].outPosition;\n  if (edgeDirection === \"in\") {\n    portPos[node].inPosition = getNextPosition(portPos[node].inPosition, edgeDirection, graphDirection);\n  } else {\n    portPos[node].outPosition = getNextPosition(portPos[node].outPosition, edgeDirection, graphDirection);\n  }\n  return result;\n};\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n  const sourceId = source;\n  const targetId = target;\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n  if (!startNode || !endNode) {\n    return {\n      source,\n      target\n    };\n  }\n  if (startNode.type === \"diamond\") {\n    source = `${source}-${getNextPort(source, \"out\", dir)}`;\n  }\n  if (endNode.type === \"diamond\") {\n    target = `${target}-${getNextPort(target, \"in\", dir)}`;\n  }\n  return {\n    source,\n    target,\n    sourceId,\n    targetId\n  };\n};\nconst addEdges = function (edges, diagObj, graph, svg) {\n  log.info(\"abc78 edges = \", edges);\n  const labelsEl = svg.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n  edges.forEach(function (edge) {\n    const linkIdBase = \"L-\" + edge.start + \"-\" + edge.end;\n    if (linkIdCnt[linkIdBase] === void 0) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + \"-\" + linkIdCnt[linkIdBase];\n    log.info(\"abc78 new link id to be used is\", linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    const linkNameStart = \"LS-\" + edge.start;\n    const linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = {\n      style: \"\",\n      labelStyle: \"\"\n    };\n    edgeData.minlen = edge.length || 1;\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n    edgeData.arrowTypeStart = \"arrow_open\";\n    edgeData.arrowTypeEnd = \"arrow_open\";\n    switch (edge.type) {\n      case \"double_arrow_cross\":\n        edgeData.arrowTypeStart = \"arrow_cross\";\n      case \"arrow_cross\":\n        edgeData.arrowTypeEnd = \"arrow_cross\";\n        break;\n      case \"double_arrow_point\":\n        edgeData.arrowTypeStart = \"arrow_point\";\n      case \"arrow_point\":\n        edgeData.arrowTypeEnd = \"arrow_point\";\n        break;\n      case \"double_arrow_circle\":\n        edgeData.arrowTypeStart = \"arrow_circle\";\n      case \"arrow_circle\":\n        edgeData.arrowTypeEnd = \"arrow_circle\";\n        break;\n    }\n    let style = \"\";\n    let labelStyle = \"\";\n    switch (edge.stroke) {\n      case \"normal\":\n        style = \"fill:none;\";\n        if (defaultStyle !== void 0) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== void 0) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"solid\";\n        break;\n      case \"dotted\":\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"dotted\";\n        edgeData.style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n        break;\n      case \"thick\":\n        edgeData.thickness = \"thick\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 3.5px;fill:none;\";\n        break;\n    }\n    if (edge.style !== void 0) {\n      const styles2 = getStylesFromArray(edge.style);\n      style = styles2.style;\n      labelStyle = styles2.labelStyle;\n    }\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n    }\n    edgeData.labelType = edge.labelType;\n    edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n    if (edge.style === void 0) {\n      edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none;\";\n    }\n    edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n    edgeData.id = linkId;\n    edgeData.classes = \"flowchart-link \" + linkNameStart + \" \" + linkNameEnd;\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n    const {\n      source,\n      target,\n      sourceId,\n      targetId\n    } = getEdgeStartEndPoint(edge, dir);\n    log.debug(\"abc78 source and target\", source, target);\n    graph.edges.push({\n      id: \"e\" + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      sourceId,\n      targetId,\n      labelEl,\n      labels: [{\n        width: edgeData.width,\n        height: edgeData.height,\n        orgWidth: edgeData.width,\n        orgHeight: edgeData.height,\n        text: edgeData.label,\n        layoutOptions: {\n          \"edgeLabels.inline\": \"true\",\n          \"edgeLabels.placement\": \"CENTER\"\n        }\n      }],\n      edgeData\n    });\n  });\n  return graph;\n};\nconst addMarkersToEdge = function (svgPath, edgeData, diagramType, arrowMarkerAbsolute, id) {\n  let url = \"\";\n  if (arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n  addEdgeMarkers(svgPath, edgeData, url, id, diagramType);\n};\nconst getClasses = function (text, diagObj) {\n  log.info(\"Extracting classes\");\n  return diagObj.db.getClasses();\n};\nconst addSubGraphs = function (db2) {\n  const parentLookupDb = {\n    parentById: {},\n    childrenById: {}\n  };\n  const subgraphs = db2.getSubGraphs();\n  log.info(\"Subgraphs - \", subgraphs);\n  subgraphs.forEach(function (subgraph) {\n    subgraph.nodes.forEach(function (node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n      if (parentLookupDb.childrenById[subgraph.id] === void 0) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n  subgraphs.forEach(function (subgraph) {\n    ({\n      id: subgraph.id\n    });\n    if (parentLookupDb.parentById[subgraph.id] !== void 0) {\n      parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\nconst calcOffset = function (src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n  if (ancestor === void 0 || ancestor === \"root\") {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return {\n    x: ancestorOffset.posX,\n    y: ancestorOffset.posY\n  };\n};\nconst insertEdge = function (edgesEl, edge, edgeData, diagObj, parentLookupDb, id) {\n  const offset = calcOffset(edge.sourceId, edge.targetId, parentLookupDb);\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n  const segPoints = segments.map(segment => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [[src.x + offset.x, src.y + offset.y], ...segPoints, [dest.x + offset.x, dest.y + offset.y]];\n  const {\n    x,\n    y\n  } = getLineFunctionsWithOffset(edge.edgeData);\n  const curve = line().x(x).y(y).curve(curveLinear);\n  const edgePath = edgesEl.insert(\"path\").attr(\"d\", curve(points)).attr(\"class\", \"path \" + edgeData.classes).attr(\"fill\", \"none\");\n  const edgeG = edgesEl.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr(\"width\", box.width);\n  edgeWithLabel.attr(\"height\", box.height);\n  edgeG.attr(\"transform\", `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`);\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute, id);\n};\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach(node => {\n    if (!node.children) {\n      node.children = [];\n    }\n    const childIds = parentLookupDb.childrenById[node.id];\n    if (childIds) {\n      childIds.forEach(childId => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n    insertChildren(node.children, parentLookupDb);\n  });\n};\nconst draw = async function (text, id, _version, diagObj) {\n  var _a;\n  diagObj.db.clear();\n  nodeDb = {};\n  portPos = {};\n  diagObj.db.setGen(\"gen-2\");\n  diagObj.parser.parse(text);\n  const renderEl = select(\"body\").append(\"div\").attr(\"style\", \"height:400px\").attr(\"id\", \"cy\");\n  let graph = {\n    id: \"root\",\n    layoutOptions: {\n      \"elk.hierarchyHandling\": \"INCLUDE_CHILDREN\",\n      \"org.eclipse.elk.padding\": \"[top=100, left=100, bottom=110, right=110]\",\n      \"elk.layered.spacing.edgeNodeBetweenLayers\": \"30\",\n      // 'elk.layered.mergeEdges': 'true',\n      \"elk.direction\": \"DOWN\"\n      // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n    },\n    children: [],\n    edges: []\n  };\n  log.info(\"Drawing flowchart using v3 renderer\", elk);\n  let dir = diagObj.db.getDirection();\n  switch (dir) {\n    case \"BT\":\n      graph.layoutOptions[\"elk.direction\"] = \"UP\";\n      break;\n    case \"TB\":\n      graph.layoutOptions[\"elk.direction\"] = \"DOWN\";\n      break;\n    case \"LR\":\n      graph.layoutOptions[\"elk.direction\"] = \"RIGHT\";\n      break;\n    case \"RL\":\n      graph.layoutOptions[\"elk.direction\"] = \"LEFT\";\n      break;\n  }\n  const {\n    securityLevel,\n    flowchart: conf2\n  } = getConfig();\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  const svg = root.select(`[id=\"${id}\"]`);\n  const markers = [\"point\", \"circle\", \"cross\"];\n  insertMarkers(svg, markers, diagObj.type, id);\n  const vert = diagObj.db.getVertices();\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info(\"Subgraphs - \", subGraphs);\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(subG.id, {\n      text: subG.title,\n      type: subG.labelType\n    }, \"group\", void 0, subG.classes, subG.dir);\n  }\n  const subGraphsEl = svg.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const parentLookupDb = addSubGraphs(diagObj.db);\n  graph = await addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n  const edgesEl = svg.insert(\"g\").attr(\"class\", \"edges edgePath\");\n  const edges = diagObj.db.getEdges();\n  graph = addEdges(edges, diagObj, graph, svg);\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach(nodeId => {\n    const node = nodeDb[nodeId];\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n    if (parentLookupDb.childrenById[nodeId] !== void 0) {\n      node.labels = [{\n        text: node.labelText,\n        layoutOptions: {\n          \"nodeLabels.placement\": \"[H_CENTER, V_TOP, INSIDE]\"\n        },\n        width: node.labelData.width,\n        height: node.labelData.height\n        // width: 100,\n        // height: 100,\n      }];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info(\"after layout\", JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info(\"after layout\", g);\n  (_a = g.edges) == null ? void 0 : _a.map(edge => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb, id);\n  });\n  setupGraphViewbox({}, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  renderEl.remove();\n};\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function (node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height\n      };\n      if (node.type === \"group\") {\n        const subgraphEl = subgraphsEl.insert(\"g\").attr(\"class\", \"subgraph\");\n        subgraphEl.insert(\"rect\").attr(\"class\", \"subgraph subgraph-lvl-\" + depth % 5 + \" node\").attr(\"x\", node.x + relX).attr(\"y\", node.y + relY).attr(\"width\", node.width).attr(\"height\", node.height);\n        const label = subgraphEl.insert(\"g\").attr(\"class\", \"label\");\n        const labelCentering = getConfig().flowchart.htmlLabels ? node.labelData.width / 2 : 0;\n        label.attr(\"transform\", `translate(${node.labels[0].x + relX + node.x + labelCentering}, ${node.labels[0].y + relY + node.y + 3})`);\n        label.node().appendChild(node.labelData.labelNode);\n        log.info(\"Id (UGH)= \", node.type, node.labels);\n      } else {\n        log.info(\"Id (UGH)= \", node.id);\n        node.el.attr(\"transform\", `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`);\n      }\n    }\n  });\n  nodeArray.forEach(function (node) {\n    if (node && node.type === \"group\") {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\nconst renderer = {\n  getClasses,\n  draw\n};\nconst genSections = options => {\n  let sections = \"\";\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n  return sections;\n};\nconst getStyles = options => `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.85;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n\n  .flowchart-label text {\n    text-anchor: middle;\n  }\n\n  ${genSections(options)}\n`;\nconst styles = getStyles;\nconst diagram = {\n  db,\n  renderer,\n  parser,\n  styles\n};\nexport { diagram };","map":{"version":3,"names":["d","db","p","parser","select","curveLinear","line","a","insertMarkers","e","insertNode","l","labelHelper","f","insertEdgeLabel","k","getLineFunctionsWithOffset","m","addEdgeMarkers","log","F","getConfig","o","setupGraphViewbox","getStylesFromArray","n","interpolateToCurve","common","ELK","findCommonAncestor","id1","id2","treeData","parentById","visited","Set","currentId","add","has","elk","portPos","conf","nodeDb","addVertices","vert","svgId","root","doc","diagObj","parentLookupDb","graph","svg","nodes","insert","attr","keys","Object","Promise","all","map","id","vertex","classStr","classes","length","join","styles2","styles","vertexText","text","labelData","width","height","ports","layoutOptions","radius","_shape","type","portConstraints","node","labelStyle","shape","labelText","labelType","rx","ry","class","style","link","linkTarget","tooltip","getTooltip","domId","lookUpDomId","haveCallback","dir","props","padding","flowchart","boundingBox","nodeEl","getBBox","createElementNS","shapeSvg","bbox","wrappingWidth","labelNode","data","el","parent","getNextPosition","position","edgeDirection","graphDirection","portPos2","TB","in","north","out","south","west","east","LR","RL","BT","TD","getNextPort","info","inPosition","outPosition","result","getEdgeStartEndPoint","edge","source","start","target","end","sourceId","targetId","startNode","endNode","addEdges","edges","labelsEl","linkIdCnt","getDirection","defaultStyle","defaultLabelStyle","defaultStyles","forEach","linkIdBase","linkId","linkNameStart","linkNameEnd","edgeData","minlen","arrowhead","arrowTypeStart","arrowTypeEnd","stroke","thickness","pattern","interpolate","curve","defaultInterpolate","arrowheadStyle","labelpos","label","replace","lineBreakRegex","labelEl","debug","push","sources","targets","labels","orgWidth","orgHeight","addMarkersToEdge","svgPath","diagramType","arrowMarkerAbsolute","url","window","location","protocol","host","pathname","search","getClasses","addSubGraphs","db2","childrenById","subgraphs","getSubGraphs","subgraph","calcOffset","src","dest","ancestor","x","y","ancestorOffset","offset","posX","posY","insertEdge","edgesEl","sections","startPoint","endPoint","segments","bendPoints","segPoints","segment","points","edgePath","edgeG","edgeWithLabel","appendChild","box","firstChild","getBoundingClientRect","insertChildren","nodeArray","children","childIds","childId","draw","_version","_a","clear","setGen","parse","renderEl","append","securityLevel","conf2","sandboxElement","contentDocument","body","document","markers","getVertices","subG","subGraphs","i","addVertex","title","subGraphsEl","getEdges","nodeId","JSON","stringify","g","layout","drawNodes","diagramPadding","useMaxWidth","remove","relX","relY","subgraphsEl","depth","subgraphEl","labelCentering","htmlLabels","renderer","genSections","options","getStyles","fontFamily","nodeTextColor","textColor","titleColor","mainBkg","nodeBorder","arrowheadColor","lineColor","edgeLabelBackground","clusterBkg","clusterBorder","tertiaryColor","border2","diagram"],"sources":["/Users/anasshaik/Desktop/Projects/CareerPath.AI/frontend/node_modules/mermaid/dist/flowchart-elk-definition-4a651766.js"],"sourcesContent":["import { d as db, p as parser } from \"./flowDb-956e92f1.js\";\nimport { select, curveLinear, line } from \"d3\";\nimport { a as insertMarkers, e as insertNode, l as labelHelper, f as insertEdgeLabel, k as getLineFunctionsWithOffset, m as addEdgeMarkers } from \"./edges-e0da2a9e.js\";\nimport { l as log, F as getConfig, o as setupGraphViewbox, k as getStylesFromArray, n as interpolateToCurve, e as common } from \"./mermaid-b5860b54.js\";\nimport ELK from \"elkjs/lib/elk.bundled.js\";\nimport \"./createText-2e5e7dd3.js\";\nimport \"mdast-util-from-markdown\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nconst findCommonAncestor = (id1, id2, treeData) => {\n  const { parentById } = treeData;\n  const visited = /* @__PURE__ */ new Set();\n  let currentId = id1;\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  return \"root\";\n};\nconst elk = new ELK();\nlet portPos = {};\nconst conf = {};\nlet nodeDb = {};\nconst addVertices = async function(vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert(\"g\").attr(\"class\", \"nodes\");\n  const keys = Object.keys(vert);\n  await Promise.all(\n    keys.map(async function(id) {\n      const vertex = vert[id];\n      let classStr = \"default\";\n      if (vertex.classes.length > 0) {\n        classStr = vertex.classes.join(\" \");\n      }\n      classStr = classStr + \" flowchart-label\";\n      const styles2 = getStylesFromArray(vertex.styles);\n      let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n      const labelData = { width: 0, height: 0 };\n      const ports = [\n        {\n          id: vertex.id + \"-west\",\n          layoutOptions: {\n            \"port.side\": \"WEST\"\n          }\n        },\n        {\n          id: vertex.id + \"-east\",\n          layoutOptions: {\n            \"port.side\": \"EAST\"\n          }\n        },\n        {\n          id: vertex.id + \"-south\",\n          layoutOptions: {\n            \"port.side\": \"SOUTH\"\n          }\n        },\n        {\n          id: vertex.id + \"-north\",\n          layoutOptions: {\n            \"port.side\": \"NORTH\"\n          }\n        }\n      ];\n      let radius = 0;\n      let _shape = \"\";\n      let layoutOptions = {};\n      switch (vertex.type) {\n        case \"round\":\n          radius = 5;\n          _shape = \"rect\";\n          break;\n        case \"square\":\n          _shape = \"rect\";\n          break;\n        case \"diamond\":\n          _shape = \"question\";\n          layoutOptions = {\n            portConstraints: \"FIXED_SIDE\"\n          };\n          break;\n        case \"hexagon\":\n          _shape = \"hexagon\";\n          break;\n        case \"odd\":\n          _shape = \"rect_left_inv_arrow\";\n          break;\n        case \"lean_right\":\n          _shape = \"lean_right\";\n          break;\n        case \"lean_left\":\n          _shape = \"lean_left\";\n          break;\n        case \"trapezoid\":\n          _shape = \"trapezoid\";\n          break;\n        case \"inv_trapezoid\":\n          _shape = \"inv_trapezoid\";\n          break;\n        case \"odd_right\":\n          _shape = \"rect_left_inv_arrow\";\n          break;\n        case \"circle\":\n          _shape = \"circle\";\n          break;\n        case \"ellipse\":\n          _shape = \"ellipse\";\n          break;\n        case \"stadium\":\n          _shape = \"stadium\";\n          break;\n        case \"subroutine\":\n          _shape = \"subroutine\";\n          break;\n        case \"cylinder\":\n          _shape = \"cylinder\";\n          break;\n        case \"group\":\n          _shape = \"rect\";\n          break;\n        case \"doublecircle\":\n          _shape = \"doublecircle\";\n          break;\n        default:\n          _shape = \"rect\";\n      }\n      const node = {\n        labelStyle: styles2.labelStyle,\n        shape: _shape,\n        labelText: vertexText,\n        labelType: vertex.labelType,\n        rx: radius,\n        ry: radius,\n        class: classStr,\n        style: styles2.style,\n        id: vertex.id,\n        link: vertex.link,\n        linkTarget: vertex.linkTarget,\n        tooltip: diagObj.db.getTooltip(vertex.id) || \"\",\n        domId: diagObj.db.lookUpDomId(vertex.id),\n        haveCallback: vertex.haveCallback,\n        width: vertex.type === \"group\" ? 500 : void 0,\n        dir: vertex.dir,\n        type: vertex.type,\n        props: vertex.props,\n        padding: getConfig().flowchart.padding\n      };\n      let boundingBox;\n      let nodeEl;\n      if (node.type !== \"group\") {\n        nodeEl = await insertNode(nodes, node, vertex.dir);\n        boundingBox = nodeEl.node().getBBox();\n      } else {\n        doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        const { shapeSvg, bbox } = await labelHelper(nodes, node, void 0, true);\n        labelData.width = bbox.width;\n        labelData.wrappingWidth = getConfig().flowchart.wrappingWidth;\n        labelData.height = bbox.height;\n        labelData.labelNode = shapeSvg.node();\n        node.labelData = labelData;\n      }\n      const data = {\n        id: vertex.id,\n        ports: vertex.type === \"diamond\" ? ports : [],\n        // labelStyle: styles.labelStyle,\n        // shape: _shape,\n        layoutOptions,\n        labelText: vertexText,\n        labelData,\n        // labels: [{ text: vertexText }],\n        // rx: radius,\n        // ry: radius,\n        // class: classStr,\n        // style: styles.style,\n        // link: vertex.link,\n        // linkTarget: vertex.linkTarget,\n        // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n        domId: diagObj.db.lookUpDomId(vertex.id),\n        // haveCallback: vertex.haveCallback,\n        width: boundingBox == null ? void 0 : boundingBox.width,\n        height: boundingBox == null ? void 0 : boundingBox.height,\n        // dir: vertex.dir,\n        type: vertex.type,\n        // props: vertex.props,\n        // padding: getConfig().flowchart.padding,\n        // boundingBox,\n        el: nodeEl,\n        parent: parentLookupDb.parentById[vertex.id]\n      };\n      nodeDb[node.id] = data;\n    })\n  );\n  return graph;\n};\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos2 = {\n    TB: {\n      in: {\n        north: \"north\"\n      },\n      out: {\n        south: \"west\",\n        west: \"east\",\n        east: \"south\"\n      }\n    },\n    LR: {\n      in: {\n        west: \"west\"\n      },\n      out: {\n        east: \"south\",\n        south: \"north\",\n        north: \"east\"\n      }\n    },\n    RL: {\n      in: {\n        east: \"east\"\n      },\n      out: {\n        west: \"north\",\n        north: \"south\",\n        south: \"west\"\n      }\n    },\n    BT: {\n      in: {\n        south: \"south\"\n      },\n      out: {\n        north: \"east\",\n        east: \"west\",\n        west: \"north\"\n      }\n    }\n  };\n  portPos2.TD = portPos2.TB;\n  return portPos2[graphDirection][edgeDirection][position];\n};\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info(\"getNextPort\", { node, edgeDirection, graphDirection });\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case \"TB\":\n      case \"TD\":\n        portPos[node] = {\n          inPosition: \"north\",\n          outPosition: \"south\"\n        };\n        break;\n      case \"BT\":\n        portPos[node] = {\n          inPosition: \"south\",\n          outPosition: \"north\"\n        };\n        break;\n      case \"RL\":\n        portPos[node] = {\n          inPosition: \"east\",\n          outPosition: \"west\"\n        };\n        break;\n      case \"LR\":\n        portPos[node] = {\n          inPosition: \"west\",\n          outPosition: \"east\"\n        };\n        break;\n    }\n  }\n  const result = edgeDirection === \"in\" ? portPos[node].inPosition : portPos[node].outPosition;\n  if (edgeDirection === \"in\") {\n    portPos[node].inPosition = getNextPosition(\n      portPos[node].inPosition,\n      edgeDirection,\n      graphDirection\n    );\n  } else {\n    portPos[node].outPosition = getNextPosition(\n      portPos[node].outPosition,\n      edgeDirection,\n      graphDirection\n    );\n  }\n  return result;\n};\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n  const sourceId = source;\n  const targetId = target;\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n  if (!startNode || !endNode) {\n    return { source, target };\n  }\n  if (startNode.type === \"diamond\") {\n    source = `${source}-${getNextPort(source, \"out\", dir)}`;\n  }\n  if (endNode.type === \"diamond\") {\n    target = `${target}-${getNextPort(target, \"in\", dir)}`;\n  }\n  return { source, target, sourceId, targetId };\n};\nconst addEdges = function(edges, diagObj, graph, svg) {\n  log.info(\"abc78 edges = \", edges);\n  const labelsEl = svg.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n  edges.forEach(function(edge) {\n    const linkIdBase = \"L-\" + edge.start + \"-\" + edge.end;\n    if (linkIdCnt[linkIdBase] === void 0) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + \"-\" + linkIdCnt[linkIdBase];\n    log.info(\"abc78 new link id to be used is\", linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    const linkNameStart = \"LS-\" + edge.start;\n    const linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = { style: \"\", labelStyle: \"\" };\n    edgeData.minlen = edge.length || 1;\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n    edgeData.arrowTypeStart = \"arrow_open\";\n    edgeData.arrowTypeEnd = \"arrow_open\";\n    switch (edge.type) {\n      case \"double_arrow_cross\":\n        edgeData.arrowTypeStart = \"arrow_cross\";\n      case \"arrow_cross\":\n        edgeData.arrowTypeEnd = \"arrow_cross\";\n        break;\n      case \"double_arrow_point\":\n        edgeData.arrowTypeStart = \"arrow_point\";\n      case \"arrow_point\":\n        edgeData.arrowTypeEnd = \"arrow_point\";\n        break;\n      case \"double_arrow_circle\":\n        edgeData.arrowTypeStart = \"arrow_circle\";\n      case \"arrow_circle\":\n        edgeData.arrowTypeEnd = \"arrow_circle\";\n        break;\n    }\n    let style = \"\";\n    let labelStyle = \"\";\n    switch (edge.stroke) {\n      case \"normal\":\n        style = \"fill:none;\";\n        if (defaultStyle !== void 0) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== void 0) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"solid\";\n        break;\n      case \"dotted\":\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"dotted\";\n        edgeData.style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n        break;\n      case \"thick\":\n        edgeData.thickness = \"thick\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 3.5px;fill:none;\";\n        break;\n    }\n    if (edge.style !== void 0) {\n      const styles2 = getStylesFromArray(edge.style);\n      style = styles2.style;\n      labelStyle = styles2.labelStyle;\n    }\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n    }\n    edgeData.labelType = edge.labelType;\n    edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n    if (edge.style === void 0) {\n      edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none;\";\n    }\n    edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n    edgeData.id = linkId;\n    edgeData.classes = \"flowchart-link \" + linkNameStart + \" \" + linkNameEnd;\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n    const { source, target, sourceId, targetId } = getEdgeStartEndPoint(edge, dir);\n    log.debug(\"abc78 source and target\", source, target);\n    graph.edges.push({\n      id: \"e\" + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      sourceId,\n      targetId,\n      labelEl,\n      labels: [\n        {\n          width: edgeData.width,\n          height: edgeData.height,\n          orgWidth: edgeData.width,\n          orgHeight: edgeData.height,\n          text: edgeData.label,\n          layoutOptions: {\n            \"edgeLabels.inline\": \"true\",\n            \"edgeLabels.placement\": \"CENTER\"\n          }\n        }\n      ],\n      edgeData\n    });\n  });\n  return graph;\n};\nconst addMarkersToEdge = function(svgPath, edgeData, diagramType, arrowMarkerAbsolute, id) {\n  let url = \"\";\n  if (arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n  addEdgeMarkers(svgPath, edgeData, url, id, diagramType);\n};\nconst getClasses = function(text, diagObj) {\n  log.info(\"Extracting classes\");\n  return diagObj.db.getClasses();\n};\nconst addSubGraphs = function(db2) {\n  const parentLookupDb = { parentById: {}, childrenById: {} };\n  const subgraphs = db2.getSubGraphs();\n  log.info(\"Subgraphs - \", subgraphs);\n  subgraphs.forEach(function(subgraph) {\n    subgraph.nodes.forEach(function(node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n      if (parentLookupDb.childrenById[subgraph.id] === void 0) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n  subgraphs.forEach(function(subgraph) {\n    ({ id: subgraph.id });\n    if (parentLookupDb.parentById[subgraph.id] !== void 0) {\n      parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\nconst calcOffset = function(src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n  if (ancestor === void 0 || ancestor === \"root\") {\n    return { x: 0, y: 0 };\n  }\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return { x: ancestorOffset.posX, y: ancestorOffset.posY };\n};\nconst insertEdge = function(edgesEl, edge, edgeData, diagObj, parentLookupDb, id) {\n  const offset = calcOffset(edge.sourceId, edge.targetId, parentLookupDb);\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n  const segPoints = segments.map((segment) => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [\n    [src.x + offset.x, src.y + offset.y],\n    ...segPoints,\n    [dest.x + offset.x, dest.y + offset.y]\n  ];\n  const { x, y } = getLineFunctionsWithOffset(edge.edgeData);\n  const curve = line().x(x).y(y).curve(curveLinear);\n  const edgePath = edgesEl.insert(\"path\").attr(\"d\", curve(points)).attr(\"class\", \"path \" + edgeData.classes).attr(\"fill\", \"none\");\n  const edgeG = edgesEl.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr(\"width\", box.width);\n  edgeWithLabel.attr(\"height\", box.height);\n  edgeG.attr(\n    \"transform\",\n    `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`\n  );\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute, id);\n};\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach((node) => {\n    if (!node.children) {\n      node.children = [];\n    }\n    const childIds = parentLookupDb.childrenById[node.id];\n    if (childIds) {\n      childIds.forEach((childId) => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n    insertChildren(node.children, parentLookupDb);\n  });\n};\nconst draw = async function(text, id, _version, diagObj) {\n  var _a;\n  diagObj.db.clear();\n  nodeDb = {};\n  portPos = {};\n  diagObj.db.setGen(\"gen-2\");\n  diagObj.parser.parse(text);\n  const renderEl = select(\"body\").append(\"div\").attr(\"style\", \"height:400px\").attr(\"id\", \"cy\");\n  let graph = {\n    id: \"root\",\n    layoutOptions: {\n      \"elk.hierarchyHandling\": \"INCLUDE_CHILDREN\",\n      \"org.eclipse.elk.padding\": \"[top=100, left=100, bottom=110, right=110]\",\n      \"elk.layered.spacing.edgeNodeBetweenLayers\": \"30\",\n      // 'elk.layered.mergeEdges': 'true',\n      \"elk.direction\": \"DOWN\"\n      // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n    },\n    children: [],\n    edges: []\n  };\n  log.info(\"Drawing flowchart using v3 renderer\", elk);\n  let dir = diagObj.db.getDirection();\n  switch (dir) {\n    case \"BT\":\n      graph.layoutOptions[\"elk.direction\"] = \"UP\";\n      break;\n    case \"TB\":\n      graph.layoutOptions[\"elk.direction\"] = \"DOWN\";\n      break;\n    case \"LR\":\n      graph.layoutOptions[\"elk.direction\"] = \"RIGHT\";\n      break;\n    case \"RL\":\n      graph.layoutOptions[\"elk.direction\"] = \"LEFT\";\n      break;\n  }\n  const { securityLevel, flowchart: conf2 } = getConfig();\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  const svg = root.select(`[id=\"${id}\"]`);\n  const markers = [\"point\", \"circle\", \"cross\"];\n  insertMarkers(svg, markers, diagObj.type, id);\n  const vert = diagObj.db.getVertices();\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info(\"Subgraphs - \", subGraphs);\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(\n      subG.id,\n      { text: subG.title, type: subG.labelType },\n      \"group\",\n      void 0,\n      subG.classes,\n      subG.dir\n    );\n  }\n  const subGraphsEl = svg.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const parentLookupDb = addSubGraphs(diagObj.db);\n  graph = await addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n  const edgesEl = svg.insert(\"g\").attr(\"class\", \"edges edgePath\");\n  const edges = diagObj.db.getEdges();\n  graph = addEdges(edges, diagObj, graph, svg);\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach((nodeId) => {\n    const node = nodeDb[nodeId];\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n    if (parentLookupDb.childrenById[nodeId] !== void 0) {\n      node.labels = [\n        {\n          text: node.labelText,\n          layoutOptions: {\n            \"nodeLabels.placement\": \"[H_CENTER, V_TOP, INSIDE]\"\n          },\n          width: node.labelData.width,\n          height: node.labelData.height\n          // width: 100,\n          // height: 100,\n        }\n      ];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info(\"after layout\", JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info(\"after layout\", g);\n  (_a = g.edges) == null ? void 0 : _a.map((edge) => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb, id);\n  });\n  setupGraphViewbox({}, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  renderEl.remove();\n};\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function(node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height\n      };\n      if (node.type === \"group\") {\n        const subgraphEl = subgraphsEl.insert(\"g\").attr(\"class\", \"subgraph\");\n        subgraphEl.insert(\"rect\").attr(\"class\", \"subgraph subgraph-lvl-\" + depth % 5 + \" node\").attr(\"x\", node.x + relX).attr(\"y\", node.y + relY).attr(\"width\", node.width).attr(\"height\", node.height);\n        const label = subgraphEl.insert(\"g\").attr(\"class\", \"label\");\n        const labelCentering = getConfig().flowchart.htmlLabels ? node.labelData.width / 2 : 0;\n        label.attr(\n          \"transform\",\n          `translate(${node.labels[0].x + relX + node.x + labelCentering}, ${node.labels[0].y + relY + node.y + 3})`\n        );\n        label.node().appendChild(node.labelData.labelNode);\n        log.info(\"Id (UGH)= \", node.type, node.labels);\n      } else {\n        log.info(\"Id (UGH)= \", node.id);\n        node.el.attr(\n          \"transform\",\n          `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n        );\n      }\n    }\n  });\n  nodeArray.forEach(function(node) {\n    if (node && node.type === \"group\") {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\nconst renderer = {\n  getClasses,\n  draw\n};\nconst genSections = (options) => {\n  let sections = \"\";\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n  return sections;\n};\nconst getStyles = (options) => `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.85;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n\n  .flowchart-label text {\n    text-anchor: middle;\n  }\n\n  ${genSections(options)}\n`;\nconst styles = getStyles;\nconst diagram = {\n  db,\n  renderer,\n  parser,\n  styles\n};\nexport {\n  diagram\n};\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,EAAE,EAAEC,CAAC,IAAIC,MAAM,QAAQ,sBAAsB;AAC3D,SAASC,MAAM,EAAEC,WAAW,EAAEC,IAAI,QAAQ,IAAI;AAC9C,SAASC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,UAAU,EAAEC,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,0BAA0B,EAAEC,CAAC,IAAIC,cAAc,QAAQ,qBAAqB;AACvK,SAASP,CAAC,IAAIQ,GAAG,EAAEC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,iBAAiB,EAAER,CAAC,IAAIS,kBAAkB,EAAEC,CAAC,IAAIC,kBAAkB,EAAEjB,CAAC,IAAIkB,MAAM,QAAQ,uBAAuB;AACvJ,OAAOC,GAAG,MAAM,0BAA0B;AAC1C,OAAO,0BAA0B;AACjC,OAAO,0BAA0B;AACjC,OAAO,WAAW;AAClB,OAAO,OAAO;AACd,OAAO,yBAAyB;AAChC,OAAO,WAAW;AAClB,OAAO,QAAQ;AACf,OAAO,sBAAsB;AAC7B,OAAO,oBAAoB;AAC3B,OAAO,QAAQ;AACf,OAAO,sBAAsB;AAC7B,MAAMC,kBAAkB,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,QAAQ,KAAK;EACjD,MAAM;IAAEC;EAAW,CAAC,GAAGD,QAAQ;EAC/B,MAAME,OAAO,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAAC;EACzC,IAAIC,SAAS,GAAGN,GAAG;EACnB,OAAOM,SAAS,EAAE;IAChBF,OAAO,CAACG,GAAG,CAACD,SAAS,CAAC;IACtB,IAAIA,SAAS,KAAKL,GAAG,EAAE;MACrB,OAAOK,SAAS;IAClB;IACAA,SAAS,GAAGH,UAAU,CAACG,SAAS,CAAC;EACnC;EACAA,SAAS,GAAGL,GAAG;EACf,OAAOK,SAAS,EAAE;IAChB,IAAIF,OAAO,CAACI,GAAG,CAACF,SAAS,CAAC,EAAE;MAC1B,OAAOA,SAAS;IAClB;IACAA,SAAS,GAAGH,UAAU,CAACG,SAAS,CAAC;EACnC;EACA,OAAO,MAAM;AACf,CAAC;AACD,MAAMG,GAAG,GAAG,IAAIX,GAAG,CAAC,CAAC;AACrB,IAAIY,OAAO,GAAG,CAAC,CAAC;AAChB,MAAMC,IAAI,GAAG,CAAC,CAAC;AACf,IAAIC,MAAM,GAAG,CAAC,CAAC;AACf,MAAMC,WAAW,GAAG,eAAAA,CAAeC,IAAI,EAAEC,KAAK,EAAEC,IAAI,EAAEC,GAAG,EAAEC,OAAO,EAAEC,cAAc,EAAEC,KAAK,EAAE;EACzF,MAAMC,GAAG,GAAGL,IAAI,CAAC1C,MAAM,CAAC,QAAQyC,KAAK,IAAI,CAAC;EAC1C,MAAMO,KAAK,GAAGD,GAAG,CAACE,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC;EACpD,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACX,IAAI,CAAC;EAC9B,MAAMa,OAAO,CAACC,GAAG,CACfH,IAAI,CAACI,GAAG,CAAC,gBAAeC,EAAE,EAAE;IAC1B,MAAMC,MAAM,GAAGjB,IAAI,CAACgB,EAAE,CAAC;IACvB,IAAIE,QAAQ,GAAG,SAAS;IACxB,IAAID,MAAM,CAACE,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;MAC7BF,QAAQ,GAAGD,MAAM,CAACE,OAAO,CAACE,IAAI,CAAC,GAAG,CAAC;IACrC;IACAH,QAAQ,GAAGA,QAAQ,GAAG,kBAAkB;IACxC,MAAMI,OAAO,GAAG1C,kBAAkB,CAACqC,MAAM,CAACM,MAAM,CAAC;IACjD,IAAIC,UAAU,GAAGP,MAAM,CAACQ,IAAI,KAAK,KAAK,CAAC,GAAGR,MAAM,CAACQ,IAAI,GAAGR,MAAM,CAACD,EAAE;IACjE,MAAMU,SAAS,GAAG;MAAEC,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IACzC,MAAMC,KAAK,GAAG,CACZ;MACEb,EAAE,EAAEC,MAAM,CAACD,EAAE,GAAG,OAAO;MACvBc,aAAa,EAAE;QACb,WAAW,EAAE;MACf;IACF,CAAC,EACD;MACEd,EAAE,EAAEC,MAAM,CAACD,EAAE,GAAG,OAAO;MACvBc,aAAa,EAAE;QACb,WAAW,EAAE;MACf;IACF,CAAC,EACD;MACEd,EAAE,EAAEC,MAAM,CAACD,EAAE,GAAG,QAAQ;MACxBc,aAAa,EAAE;QACb,WAAW,EAAE;MACf;IACF,CAAC,EACD;MACEd,EAAE,EAAEC,MAAM,CAACD,EAAE,GAAG,QAAQ;MACxBc,aAAa,EAAE;QACb,WAAW,EAAE;MACf;IACF,CAAC,CACF;IACD,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIF,aAAa,GAAG,CAAC,CAAC;IACtB,QAAQb,MAAM,CAACgB,IAAI;MACjB,KAAK,OAAO;QACVF,MAAM,GAAG,CAAC;QACVC,MAAM,GAAG,MAAM;QACf;MACF,KAAK,QAAQ;QACXA,MAAM,GAAG,MAAM;QACf;MACF,KAAK,SAAS;QACZA,MAAM,GAAG,UAAU;QACnBF,aAAa,GAAG;UACdI,eAAe,EAAE;QACnB,CAAC;QACD;MACF,KAAK,SAAS;QACZF,MAAM,GAAG,SAAS;QAClB;MACF,KAAK,KAAK;QACRA,MAAM,GAAG,qBAAqB;QAC9B;MACF,KAAK,YAAY;QACfA,MAAM,GAAG,YAAY;QACrB;MACF,KAAK,WAAW;QACdA,MAAM,GAAG,WAAW;QACpB;MACF,KAAK,WAAW;QACdA,MAAM,GAAG,WAAW;QACpB;MACF,KAAK,eAAe;QAClBA,MAAM,GAAG,eAAe;QACxB;MACF,KAAK,WAAW;QACdA,MAAM,GAAG,qBAAqB;QAC9B;MACF,KAAK,QAAQ;QACXA,MAAM,GAAG,QAAQ;QACjB;MACF,KAAK,SAAS;QACZA,MAAM,GAAG,SAAS;QAClB;MACF,KAAK,SAAS;QACZA,MAAM,GAAG,SAAS;QAClB;MACF,KAAK,YAAY;QACfA,MAAM,GAAG,YAAY;QACrB;MACF,KAAK,UAAU;QACbA,MAAM,GAAG,UAAU;QACnB;MACF,KAAK,OAAO;QACVA,MAAM,GAAG,MAAM;QACf;MACF,KAAK,cAAc;QACjBA,MAAM,GAAG,cAAc;QACvB;MACF;QACEA,MAAM,GAAG,MAAM;IACnB;IACA,MAAMG,IAAI,GAAG;MACXC,UAAU,EAAEd,OAAO,CAACc,UAAU;MAC9BC,KAAK,EAAEL,MAAM;MACbM,SAAS,EAAEd,UAAU;MACrBe,SAAS,EAAEtB,MAAM,CAACsB,SAAS;MAC3BC,EAAE,EAAET,MAAM;MACVU,EAAE,EAAEV,MAAM;MACVW,KAAK,EAAExB,QAAQ;MACfyB,KAAK,EAAErB,OAAO,CAACqB,KAAK;MACpB3B,EAAE,EAAEC,MAAM,CAACD,EAAE;MACb4B,IAAI,EAAE3B,MAAM,CAAC2B,IAAI;MACjBC,UAAU,EAAE5B,MAAM,CAAC4B,UAAU;MAC7BC,OAAO,EAAE1C,OAAO,CAAC/C,EAAE,CAAC0F,UAAU,CAAC9B,MAAM,CAACD,EAAE,CAAC,IAAI,EAAE;MAC/CgC,KAAK,EAAE5C,OAAO,CAAC/C,EAAE,CAAC4F,WAAW,CAAChC,MAAM,CAACD,EAAE,CAAC;MACxCkC,YAAY,EAAEjC,MAAM,CAACiC,YAAY;MACjCvB,KAAK,EAAEV,MAAM,CAACgB,IAAI,KAAK,OAAO,GAAG,GAAG,GAAG,KAAK,CAAC;MAC7CkB,GAAG,EAAElC,MAAM,CAACkC,GAAG;MACflB,IAAI,EAAEhB,MAAM,CAACgB,IAAI;MACjBmB,KAAK,EAAEnC,MAAM,CAACmC,KAAK;MACnBC,OAAO,EAAE5E,SAAS,CAAC,CAAC,CAAC6E,SAAS,CAACD;IACjC,CAAC;IACD,IAAIE,WAAW;IACf,IAAIC,MAAM;IACV,IAAIrB,IAAI,CAACF,IAAI,KAAK,OAAO,EAAE;MACzBuB,MAAM,GAAG,MAAM1F,UAAU,CAAC0C,KAAK,EAAE2B,IAAI,EAAElB,MAAM,CAACkC,GAAG,CAAC;MAClDI,WAAW,GAAGC,MAAM,CAACrB,IAAI,CAAC,CAAC,CAACsB,OAAO,CAAC,CAAC;IACvC,CAAC,MAAM;MACLtD,GAAG,CAACuD,eAAe,CAAC,4BAA4B,EAAE,MAAM,CAAC;MACzD,MAAM;QAAEC,QAAQ;QAAEC;MAAK,CAAC,GAAG,MAAM5F,WAAW,CAACwC,KAAK,EAAE2B,IAAI,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC;MACvET,SAAS,CAACC,KAAK,GAAGiC,IAAI,CAACjC,KAAK;MAC5BD,SAAS,CAACmC,aAAa,GAAGpF,SAAS,CAAC,CAAC,CAAC6E,SAAS,CAACO,aAAa;MAC7DnC,SAAS,CAACE,MAAM,GAAGgC,IAAI,CAAChC,MAAM;MAC9BF,SAAS,CAACoC,SAAS,GAAGH,QAAQ,CAACxB,IAAI,CAAC,CAAC;MACrCA,IAAI,CAACT,SAAS,GAAGA,SAAS;IAC5B;IACA,MAAMqC,IAAI,GAAG;MACX/C,EAAE,EAAEC,MAAM,CAACD,EAAE;MACba,KAAK,EAAEZ,MAAM,CAACgB,IAAI,KAAK,SAAS,GAAGJ,KAAK,GAAG,EAAE;MAC7C;MACA;MACAC,aAAa;MACbQ,SAAS,EAAEd,UAAU;MACrBE,SAAS;MACT;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACAsB,KAAK,EAAE5C,OAAO,CAAC/C,EAAE,CAAC4F,WAAW,CAAChC,MAAM,CAACD,EAAE,CAAC;MACxC;MACAW,KAAK,EAAE4B,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAAC5B,KAAK;MACvDC,MAAM,EAAE2B,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAAC3B,MAAM;MACzD;MACAK,IAAI,EAAEhB,MAAM,CAACgB,IAAI;MACjB;MACA;MACA;MACA+B,EAAE,EAAER,MAAM;MACVS,MAAM,EAAE5D,cAAc,CAAChB,UAAU,CAAC4B,MAAM,CAACD,EAAE;IAC7C,CAAC;IACDlB,MAAM,CAACqC,IAAI,CAACnB,EAAE,CAAC,GAAG+C,IAAI;EACxB,CAAC,CACH,CAAC;EACD,OAAOzD,KAAK;AACd,CAAC;AACD,MAAM4D,eAAe,GAAGA,CAACC,QAAQ,EAAEC,aAAa,EAAEC,cAAc,KAAK;EACnE,MAAMC,QAAQ,GAAG;IACfC,EAAE,EAAE;MACFC,EAAE,EAAE;QACFC,KAAK,EAAE;MACT,CAAC;MACDC,GAAG,EAAE;QACHC,KAAK,EAAE,MAAM;QACbC,IAAI,EAAE,MAAM;QACZC,IAAI,EAAE;MACR;IACF,CAAC;IACDC,EAAE,EAAE;MACFN,EAAE,EAAE;QACFI,IAAI,EAAE;MACR,CAAC;MACDF,GAAG,EAAE;QACHG,IAAI,EAAE,OAAO;QACbF,KAAK,EAAE,OAAO;QACdF,KAAK,EAAE;MACT;IACF,CAAC;IACDM,EAAE,EAAE;MACFP,EAAE,EAAE;QACFK,IAAI,EAAE;MACR,CAAC;MACDH,GAAG,EAAE;QACHE,IAAI,EAAE,OAAO;QACbH,KAAK,EAAE,OAAO;QACdE,KAAK,EAAE;MACT;IACF,CAAC;IACDK,EAAE,EAAE;MACFR,EAAE,EAAE;QACFG,KAAK,EAAE;MACT,CAAC;MACDD,GAAG,EAAE;QACHD,KAAK,EAAE,MAAM;QACbI,IAAI,EAAE,MAAM;QACZD,IAAI,EAAE;MACR;IACF;EACF,CAAC;EACDN,QAAQ,CAACW,EAAE,GAAGX,QAAQ,CAACC,EAAE;EACzB,OAAOD,QAAQ,CAACD,cAAc,CAAC,CAACD,aAAa,CAAC,CAACD,QAAQ,CAAC;AAC1D,CAAC;AACD,MAAMe,WAAW,GAAGA,CAAC/C,IAAI,EAAEiC,aAAa,EAAEC,cAAc,KAAK;EAC3D9F,GAAG,CAAC4G,IAAI,CAAC,aAAa,EAAE;IAAEhD,IAAI;IAAEiC,aAAa;IAAEC;EAAe,CAAC,CAAC;EAChE,IAAI,CAACzE,OAAO,CAACuC,IAAI,CAAC,EAAE;IAClB,QAAQkC,cAAc;MACpB,KAAK,IAAI;MACT,KAAK,IAAI;QACPzE,OAAO,CAACuC,IAAI,CAAC,GAAG;UACdiD,UAAU,EAAE,OAAO;UACnBC,WAAW,EAAE;QACf,CAAC;QACD;MACF,KAAK,IAAI;QACPzF,OAAO,CAACuC,IAAI,CAAC,GAAG;UACdiD,UAAU,EAAE,OAAO;UACnBC,WAAW,EAAE;QACf,CAAC;QACD;MACF,KAAK,IAAI;QACPzF,OAAO,CAACuC,IAAI,CAAC,GAAG;UACdiD,UAAU,EAAE,MAAM;UAClBC,WAAW,EAAE;QACf,CAAC;QACD;MACF,KAAK,IAAI;QACPzF,OAAO,CAACuC,IAAI,CAAC,GAAG;UACdiD,UAAU,EAAE,MAAM;UAClBC,WAAW,EAAE;QACf,CAAC;QACD;IACJ;EACF;EACA,MAAMC,MAAM,GAAGlB,aAAa,KAAK,IAAI,GAAGxE,OAAO,CAACuC,IAAI,CAAC,CAACiD,UAAU,GAAGxF,OAAO,CAACuC,IAAI,CAAC,CAACkD,WAAW;EAC5F,IAAIjB,aAAa,KAAK,IAAI,EAAE;IAC1BxE,OAAO,CAACuC,IAAI,CAAC,CAACiD,UAAU,GAAGlB,eAAe,CACxCtE,OAAO,CAACuC,IAAI,CAAC,CAACiD,UAAU,EACxBhB,aAAa,EACbC,cACF,CAAC;EACH,CAAC,MAAM;IACLzE,OAAO,CAACuC,IAAI,CAAC,CAACkD,WAAW,GAAGnB,eAAe,CACzCtE,OAAO,CAACuC,IAAI,CAAC,CAACkD,WAAW,EACzBjB,aAAa,EACbC,cACF,CAAC;EACH;EACA,OAAOiB,MAAM;AACf,CAAC;AACD,MAAMC,oBAAoB,GAAGA,CAACC,IAAI,EAAErC,GAAG,KAAK;EAC1C,IAAIsC,MAAM,GAAGD,IAAI,CAACE,KAAK;EACvB,IAAIC,MAAM,GAAGH,IAAI,CAACI,GAAG;EACrB,MAAMC,QAAQ,GAAGJ,MAAM;EACvB,MAAMK,QAAQ,GAAGH,MAAM;EACvB,MAAMI,SAAS,GAAGjG,MAAM,CAAC2F,MAAM,CAAC;EAChC,MAAMO,OAAO,GAAGlG,MAAM,CAAC6F,MAAM,CAAC;EAC9B,IAAI,CAACI,SAAS,IAAI,CAACC,OAAO,EAAE;IAC1B,OAAO;MAAEP,MAAM;MAAEE;IAAO,CAAC;EAC3B;EACA,IAAII,SAAS,CAAC9D,IAAI,KAAK,SAAS,EAAE;IAChCwD,MAAM,GAAG,GAAGA,MAAM,IAAIP,WAAW,CAACO,MAAM,EAAE,KAAK,EAAEtC,GAAG,CAAC,EAAE;EACzD;EACA,IAAI6C,OAAO,CAAC/D,IAAI,KAAK,SAAS,EAAE;IAC9B0D,MAAM,GAAG,GAAGA,MAAM,IAAIT,WAAW,CAACS,MAAM,EAAE,IAAI,EAAExC,GAAG,CAAC,EAAE;EACxD;EACA,OAAO;IAAEsC,MAAM;IAAEE,MAAM;IAAEE,QAAQ;IAAEC;EAAS,CAAC;AAC/C,CAAC;AACD,MAAMG,QAAQ,GAAG,SAAAA,CAASC,KAAK,EAAE9F,OAAO,EAAEE,KAAK,EAAEC,GAAG,EAAE;EACpDhC,GAAG,CAAC4G,IAAI,CAAC,gBAAgB,EAAEe,KAAK,CAAC;EACjC,MAAMC,QAAQ,GAAG5F,GAAG,CAACE,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,YAAY,CAAC;EAC5D,IAAI0F,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIjD,GAAG,GAAG/C,OAAO,CAAC/C,EAAE,CAACgJ,YAAY,CAAC,CAAC;EACnC,IAAIC,YAAY;EAChB,IAAIC,iBAAiB;EACrB,IAAIL,KAAK,CAACI,YAAY,KAAK,KAAK,CAAC,EAAE;IACjC,MAAME,aAAa,GAAG5H,kBAAkB,CAACsH,KAAK,CAACI,YAAY,CAAC;IAC5DA,YAAY,GAAGE,aAAa,CAAC7D,KAAK;IAClC4D,iBAAiB,GAAGC,aAAa,CAACpE,UAAU;EAC9C;EACA8D,KAAK,CAACO,OAAO,CAAC,UAASjB,IAAI,EAAE;IAC3B,MAAMkB,UAAU,GAAG,IAAI,GAAGlB,IAAI,CAACE,KAAK,GAAG,GAAG,GAAGF,IAAI,CAACI,GAAG;IACrD,IAAIQ,SAAS,CAACM,UAAU,CAAC,KAAK,KAAK,CAAC,EAAE;MACpCN,SAAS,CAACM,UAAU,CAAC,GAAG,CAAC;MACzBnI,GAAG,CAAC4G,IAAI,CAAC,iBAAiB,EAAEuB,UAAU,EAAEN,SAAS,CAACM,UAAU,CAAC,CAAC;IAChE,CAAC,MAAM;MACLN,SAAS,CAACM,UAAU,CAAC,EAAE;MACvBnI,GAAG,CAAC4G,IAAI,CAAC,iBAAiB,EAAEuB,UAAU,EAAEN,SAAS,CAACM,UAAU,CAAC,CAAC;IAChE;IACA,IAAIC,MAAM,GAAGD,UAAU,GAAG,GAAG,GAAGN,SAAS,CAACM,UAAU,CAAC;IACrDnI,GAAG,CAAC4G,IAAI,CAAC,iCAAiC,EAAEuB,UAAU,EAAEC,MAAM,EAAEP,SAAS,CAACM,UAAU,CAAC,CAAC;IACtF,MAAME,aAAa,GAAG,KAAK,GAAGpB,IAAI,CAACE,KAAK;IACxC,MAAMmB,WAAW,GAAG,KAAK,GAAGrB,IAAI,CAACI,GAAG;IACpC,MAAMkB,QAAQ,GAAG;MAAEnE,KAAK,EAAE,EAAE;MAAEP,UAAU,EAAE;IAAG,CAAC;IAC9C0E,QAAQ,CAACC,MAAM,GAAGvB,IAAI,CAACpE,MAAM,IAAI,CAAC;IAClC,IAAIoE,IAAI,CAACvD,IAAI,KAAK,YAAY,EAAE;MAC9B6E,QAAQ,CAACE,SAAS,GAAG,MAAM;IAC7B,CAAC,MAAM;MACLF,QAAQ,CAACE,SAAS,GAAG,QAAQ;IAC/B;IACAF,QAAQ,CAACG,cAAc,GAAG,YAAY;IACtCH,QAAQ,CAACI,YAAY,GAAG,YAAY;IACpC,QAAQ1B,IAAI,CAACvD,IAAI;MACf,KAAK,oBAAoB;QACvB6E,QAAQ,CAACG,cAAc,GAAG,aAAa;MACzC,KAAK,aAAa;QAChBH,QAAQ,CAACI,YAAY,GAAG,aAAa;QACrC;MACF,KAAK,oBAAoB;QACvBJ,QAAQ,CAACG,cAAc,GAAG,aAAa;MACzC,KAAK,aAAa;QAChBH,QAAQ,CAACI,YAAY,GAAG,aAAa;QACrC;MACF,KAAK,qBAAqB;QACxBJ,QAAQ,CAACG,cAAc,GAAG,cAAc;MAC1C,KAAK,cAAc;QACjBH,QAAQ,CAACI,YAAY,GAAG,cAAc;QACtC;IACJ;IACA,IAAIvE,KAAK,GAAG,EAAE;IACd,IAAIP,UAAU,GAAG,EAAE;IACnB,QAAQoD,IAAI,CAAC2B,MAAM;MACjB,KAAK,QAAQ;QACXxE,KAAK,GAAG,YAAY;QACpB,IAAI2D,YAAY,KAAK,KAAK,CAAC,EAAE;UAC3B3D,KAAK,GAAG2D,YAAY;QACtB;QACA,IAAIC,iBAAiB,KAAK,KAAK,CAAC,EAAE;UAChCnE,UAAU,GAAGmE,iBAAiB;QAChC;QACAO,QAAQ,CAACM,SAAS,GAAG,QAAQ;QAC7BN,QAAQ,CAACO,OAAO,GAAG,OAAO;QAC1B;MACF,KAAK,QAAQ;QACXP,QAAQ,CAACM,SAAS,GAAG,QAAQ;QAC7BN,QAAQ,CAACO,OAAO,GAAG,QAAQ;QAC3BP,QAAQ,CAACnE,KAAK,GAAG,gDAAgD;QACjE;MACF,KAAK,OAAO;QACVmE,QAAQ,CAACM,SAAS,GAAG,OAAO;QAC5BN,QAAQ,CAACO,OAAO,GAAG,OAAO;QAC1BP,QAAQ,CAACnE,KAAK,GAAG,gCAAgC;QACjD;IACJ;IACA,IAAI6C,IAAI,CAAC7C,KAAK,KAAK,KAAK,CAAC,EAAE;MACzB,MAAMrB,OAAO,GAAG1C,kBAAkB,CAAC4G,IAAI,CAAC7C,KAAK,CAAC;MAC9CA,KAAK,GAAGrB,OAAO,CAACqB,KAAK;MACrBP,UAAU,GAAGd,OAAO,CAACc,UAAU;IACjC;IACA0E,QAAQ,CAACnE,KAAK,GAAGmE,QAAQ,CAACnE,KAAK,IAAIA,KAAK;IACxCmE,QAAQ,CAAC1E,UAAU,GAAG0E,QAAQ,CAAC1E,UAAU,IAAIA,UAAU;IACvD,IAAIoD,IAAI,CAAC8B,WAAW,KAAK,KAAK,CAAC,EAAE;MAC/BR,QAAQ,CAACS,KAAK,GAAGzI,kBAAkB,CAAC0G,IAAI,CAAC8B,WAAW,EAAE7J,WAAW,CAAC;IACpE,CAAC,MAAM,IAAIyI,KAAK,CAACsB,kBAAkB,KAAK,KAAK,CAAC,EAAE;MAC9CV,QAAQ,CAACS,KAAK,GAAGzI,kBAAkB,CAACoH,KAAK,CAACsB,kBAAkB,EAAE/J,WAAW,CAAC;IAC5E,CAAC,MAAM;MACLqJ,QAAQ,CAACS,KAAK,GAAGzI,kBAAkB,CAACe,IAAI,CAAC0H,KAAK,EAAE9J,WAAW,CAAC;IAC9D;IACA,IAAI+H,IAAI,CAAC/D,IAAI,KAAK,KAAK,CAAC,EAAE;MACxB,IAAI+D,IAAI,CAAC7C,KAAK,KAAK,KAAK,CAAC,EAAE;QACzBmE,QAAQ,CAACW,cAAc,GAAG,YAAY;MACxC;IACF,CAAC,MAAM;MACLX,QAAQ,CAACW,cAAc,GAAG,YAAY;MACtCX,QAAQ,CAACY,QAAQ,GAAG,GAAG;IACzB;IACAZ,QAAQ,CAACvE,SAAS,GAAGiD,IAAI,CAACjD,SAAS;IACnCuE,QAAQ,CAACa,KAAK,GAAGnC,IAAI,CAAC/D,IAAI,CAACmG,OAAO,CAAC7I,MAAM,CAAC8I,cAAc,EAAE,IAAI,CAAC;IAC/D,IAAIrC,IAAI,CAAC7C,KAAK,KAAK,KAAK,CAAC,EAAE;MACzBmE,QAAQ,CAACnE,KAAK,GAAGmE,QAAQ,CAACnE,KAAK,IAAI,8CAA8C;IACnF;IACAmE,QAAQ,CAAC1E,UAAU,GAAG0E,QAAQ,CAAC1E,UAAU,CAACwF,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC;IACpEd,QAAQ,CAAC9F,EAAE,GAAG2F,MAAM;IACpBG,QAAQ,CAAC3F,OAAO,GAAG,iBAAiB,GAAGyF,aAAa,GAAG,GAAG,GAAGC,WAAW;IACxE,MAAMiB,OAAO,GAAG5J,eAAe,CAACiI,QAAQ,EAAEW,QAAQ,CAAC;IACnD,MAAM;MAAErB,MAAM;MAAEE,MAAM;MAAEE,QAAQ;MAAEC;IAAS,CAAC,GAAGP,oBAAoB,CAACC,IAAI,EAAErC,GAAG,CAAC;IAC9E5E,GAAG,CAACwJ,KAAK,CAAC,yBAAyB,EAAEtC,MAAM,EAAEE,MAAM,CAAC;IACpDrF,KAAK,CAAC4F,KAAK,CAAC8B,IAAI,CAAC;MACfhH,EAAE,EAAE,GAAG,GAAGwE,IAAI,CAACE,KAAK,GAAGF,IAAI,CAACI,GAAG;MAC/BqC,OAAO,EAAE,CAACxC,MAAM,CAAC;MACjByC,OAAO,EAAE,CAACvC,MAAM,CAAC;MACjBE,QAAQ;MACRC,QAAQ;MACRgC,OAAO;MACPK,MAAM,EAAE,CACN;QACExG,KAAK,EAAEmF,QAAQ,CAACnF,KAAK;QACrBC,MAAM,EAAEkF,QAAQ,CAAClF,MAAM;QACvBwG,QAAQ,EAAEtB,QAAQ,CAACnF,KAAK;QACxB0G,SAAS,EAAEvB,QAAQ,CAAClF,MAAM;QAC1BH,IAAI,EAAEqF,QAAQ,CAACa,KAAK;QACpB7F,aAAa,EAAE;UACb,mBAAmB,EAAE,MAAM;UAC3B,sBAAsB,EAAE;QAC1B;MACF,CAAC,CACF;MACDgF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOxG,KAAK;AACd,CAAC;AACD,MAAMgI,gBAAgB,GAAG,SAAAA,CAASC,OAAO,EAAEzB,QAAQ,EAAE0B,WAAW,EAAEC,mBAAmB,EAAEzH,EAAE,EAAE;EACzF,IAAI0H,GAAG,GAAG,EAAE;EACZ,IAAID,mBAAmB,EAAE;IACvBC,GAAG,GAAGC,MAAM,CAACC,QAAQ,CAACC,QAAQ,GAAG,IAAI,GAAGF,MAAM,CAACC,QAAQ,CAACE,IAAI,GAAGH,MAAM,CAACC,QAAQ,CAACG,QAAQ,GAAGJ,MAAM,CAACC,QAAQ,CAACI,MAAM;IAChHN,GAAG,GAAGA,GAAG,CAACd,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;IAC/Bc,GAAG,GAAGA,GAAG,CAACd,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;EACjC;EACAtJ,cAAc,CAACiK,OAAO,EAAEzB,QAAQ,EAAE4B,GAAG,EAAE1H,EAAE,EAAEwH,WAAW,CAAC;AACzD,CAAC;AACD,MAAMS,UAAU,GAAG,SAAAA,CAASxH,IAAI,EAAErB,OAAO,EAAE;EACzC7B,GAAG,CAAC4G,IAAI,CAAC,oBAAoB,CAAC;EAC9B,OAAO/E,OAAO,CAAC/C,EAAE,CAAC4L,UAAU,CAAC,CAAC;AAChC,CAAC;AACD,MAAMC,YAAY,GAAG,SAAAA,CAASC,GAAG,EAAE;EACjC,MAAM9I,cAAc,GAAG;IAAEhB,UAAU,EAAE,CAAC,CAAC;IAAE+J,YAAY,EAAE,CAAC;EAAE,CAAC;EAC3D,MAAMC,SAAS,GAAGF,GAAG,CAACG,YAAY,CAAC,CAAC;EACpC/K,GAAG,CAAC4G,IAAI,CAAC,cAAc,EAAEkE,SAAS,CAAC;EACnCA,SAAS,CAAC5C,OAAO,CAAC,UAAS8C,QAAQ,EAAE;IACnCA,QAAQ,CAAC/I,KAAK,CAACiG,OAAO,CAAC,UAAStE,IAAI,EAAE;MACpC9B,cAAc,CAAChB,UAAU,CAAC8C,IAAI,CAAC,GAAGoH,QAAQ,CAACvI,EAAE;MAC7C,IAAIX,cAAc,CAAC+I,YAAY,CAACG,QAAQ,CAACvI,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE;QACvDX,cAAc,CAAC+I,YAAY,CAACG,QAAQ,CAACvI,EAAE,CAAC,GAAG,EAAE;MAC/C;MACAX,cAAc,CAAC+I,YAAY,CAACG,QAAQ,CAACvI,EAAE,CAAC,CAACgH,IAAI,CAAC7F,IAAI,CAAC;IACrD,CAAC,CAAC;EACJ,CAAC,CAAC;EACFkH,SAAS,CAAC5C,OAAO,CAAC,UAAS8C,QAAQ,EAAE;IACnC,CAAC;MAAEvI,EAAE,EAAEuI,QAAQ,CAACvI;IAAG,CAAC;IACpB,IAAIX,cAAc,CAAChB,UAAU,CAACkK,QAAQ,CAACvI,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE;MACrDX,cAAc,CAAChB,UAAU,CAACkK,QAAQ,CAACvI,EAAE,CAAC;IACxC;EACF,CAAC,CAAC;EACF,OAAOX,cAAc;AACvB,CAAC;AACD,MAAMmJ,UAAU,GAAG,SAAAA,CAASC,GAAG,EAAEC,IAAI,EAAErJ,cAAc,EAAE;EACrD,MAAMsJ,QAAQ,GAAG1K,kBAAkB,CAACwK,GAAG,EAAEC,IAAI,EAAErJ,cAAc,CAAC;EAC9D,IAAIsJ,QAAQ,KAAK,KAAK,CAAC,IAAIA,QAAQ,KAAK,MAAM,EAAE;IAC9C,OAAO;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;EACvB;EACA,MAAMC,cAAc,GAAGhK,MAAM,CAAC6J,QAAQ,CAAC,CAACI,MAAM;EAC9C,OAAO;IAAEH,CAAC,EAAEE,cAAc,CAACE,IAAI;IAAEH,CAAC,EAAEC,cAAc,CAACG;EAAK,CAAC;AAC3D,CAAC;AACD,MAAMC,UAAU,GAAG,SAAAA,CAASC,OAAO,EAAE3E,IAAI,EAAEsB,QAAQ,EAAE1G,OAAO,EAAEC,cAAc,EAAEW,EAAE,EAAE;EAChF,MAAM+I,MAAM,GAAGP,UAAU,CAAChE,IAAI,CAACK,QAAQ,EAAEL,IAAI,CAACM,QAAQ,EAAEzF,cAAc,CAAC;EACvE,MAAMoJ,GAAG,GAAGjE,IAAI,CAAC4E,QAAQ,CAAC,CAAC,CAAC,CAACC,UAAU;EACvC,MAAMX,IAAI,GAAGlE,IAAI,CAAC4E,QAAQ,CAAC,CAAC,CAAC,CAACE,QAAQ;EACtC,MAAMC,QAAQ,GAAG/E,IAAI,CAAC4E,QAAQ,CAAC,CAAC,CAAC,CAACI,UAAU,GAAGhF,IAAI,CAAC4E,QAAQ,CAAC,CAAC,CAAC,CAACI,UAAU,GAAG,EAAE;EAC/E,MAAMC,SAAS,GAAGF,QAAQ,CAACxJ,GAAG,CAAE2J,OAAO,IAAK,CAACA,OAAO,CAACd,CAAC,GAAGG,MAAM,CAACH,CAAC,EAAEc,OAAO,CAACb,CAAC,GAAGE,MAAM,CAACF,CAAC,CAAC,CAAC;EACzF,MAAMc,MAAM,GAAG,CACb,CAAClB,GAAG,CAACG,CAAC,GAAGG,MAAM,CAACH,CAAC,EAAEH,GAAG,CAACI,CAAC,GAAGE,MAAM,CAACF,CAAC,CAAC,EACpC,GAAGY,SAAS,EACZ,CAACf,IAAI,CAACE,CAAC,GAAGG,MAAM,CAACH,CAAC,EAAEF,IAAI,CAACG,CAAC,GAAGE,MAAM,CAACF,CAAC,CAAC,CACvC;EACD,MAAM;IAAED,CAAC;IAAEC;EAAE,CAAC,GAAGzL,0BAA0B,CAACoH,IAAI,CAACsB,QAAQ,CAAC;EAC1D,MAAMS,KAAK,GAAG7J,IAAI,CAAC,CAAC,CAACkM,CAAC,CAACA,CAAC,CAAC,CAACC,CAAC,CAACA,CAAC,CAAC,CAACtC,KAAK,CAAC9J,WAAW,CAAC;EACjD,MAAMmN,QAAQ,GAAGT,OAAO,CAAC1J,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,GAAG,EAAE6G,KAAK,CAACoD,MAAM,CAAC,CAAC,CAACjK,IAAI,CAAC,OAAO,EAAE,OAAO,GAAGoG,QAAQ,CAAC3F,OAAO,CAAC,CAACT,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;EAC/H,MAAMmK,KAAK,GAAGV,OAAO,CAAC1J,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC;EAC5D,MAAMoK,aAAa,GAAGtN,MAAM,CAACqN,KAAK,CAAC1I,IAAI,CAAC,CAAC,CAAC4I,WAAW,CAACvF,IAAI,CAACsC,OAAO,CAAC,CAAC;EACpE,MAAMkD,GAAG,GAAGF,aAAa,CAAC3I,IAAI,CAAC,CAAC,CAAC8I,UAAU,CAACC,qBAAqB,CAAC,CAAC;EACnEJ,aAAa,CAACpK,IAAI,CAAC,OAAO,EAAEsK,GAAG,CAACrJ,KAAK,CAAC;EACtCmJ,aAAa,CAACpK,IAAI,CAAC,QAAQ,EAAEsK,GAAG,CAACpJ,MAAM,CAAC;EACxCiJ,KAAK,CAACnK,IAAI,CACR,WAAW,EACX,aAAa8E,IAAI,CAAC2C,MAAM,CAAC,CAAC,CAAC,CAACyB,CAAC,GAAGG,MAAM,CAACH,CAAC,KAAKpE,IAAI,CAAC2C,MAAM,CAAC,CAAC,CAAC,CAAC0B,CAAC,GAAGE,MAAM,CAACF,CAAC,GAC1E,CAAC;EACDvB,gBAAgB,CAACsC,QAAQ,EAAE9D,QAAQ,EAAE1G,OAAO,CAAC6B,IAAI,EAAE7B,OAAO,CAACqI,mBAAmB,EAAEzH,EAAE,CAAC;AACrF,CAAC;AACD,MAAMmK,cAAc,GAAGA,CAACC,SAAS,EAAE/K,cAAc,KAAK;EACpD+K,SAAS,CAAC3E,OAAO,CAAEtE,IAAI,IAAK;IAC1B,IAAI,CAACA,IAAI,CAACkJ,QAAQ,EAAE;MAClBlJ,IAAI,CAACkJ,QAAQ,GAAG,EAAE;IACpB;IACA,MAAMC,QAAQ,GAAGjL,cAAc,CAAC+I,YAAY,CAACjH,IAAI,CAACnB,EAAE,CAAC;IACrD,IAAIsK,QAAQ,EAAE;MACZA,QAAQ,CAAC7E,OAAO,CAAE8E,OAAO,IAAK;QAC5BpJ,IAAI,CAACkJ,QAAQ,CAACrD,IAAI,CAAClI,MAAM,CAACyL,OAAO,CAAC,CAAC;MACrC,CAAC,CAAC;IACJ;IACAJ,cAAc,CAAChJ,IAAI,CAACkJ,QAAQ,EAAEhL,cAAc,CAAC;EAC/C,CAAC,CAAC;AACJ,CAAC;AACD,MAAMmL,IAAI,GAAG,eAAAA,CAAe/J,IAAI,EAAET,EAAE,EAAEyK,QAAQ,EAAErL,OAAO,EAAE;EACvD,IAAIsL,EAAE;EACNtL,OAAO,CAAC/C,EAAE,CAACsO,KAAK,CAAC,CAAC;EAClB7L,MAAM,GAAG,CAAC,CAAC;EACXF,OAAO,GAAG,CAAC,CAAC;EACZQ,OAAO,CAAC/C,EAAE,CAACuO,MAAM,CAAC,OAAO,CAAC;EAC1BxL,OAAO,CAAC7C,MAAM,CAACsO,KAAK,CAACpK,IAAI,CAAC;EAC1B,MAAMqK,QAAQ,GAAGtO,MAAM,CAAC,MAAM,CAAC,CAACuO,MAAM,CAAC,KAAK,CAAC,CAACrL,IAAI,CAAC,OAAO,EAAE,cAAc,CAAC,CAACA,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;EAC5F,IAAIJ,KAAK,GAAG;IACVU,EAAE,EAAE,MAAM;IACVc,aAAa,EAAE;MACb,uBAAuB,EAAE,kBAAkB;MAC3C,yBAAyB,EAAE,4CAA4C;MACvE,2CAA2C,EAAE,IAAI;MACjD;MACA,eAAe,EAAE;MACjB;MACA;IACF,CAAC;IACDuJ,QAAQ,EAAE,EAAE;IACZnF,KAAK,EAAE;EACT,CAAC;EACD3H,GAAG,CAAC4G,IAAI,CAAC,qCAAqC,EAAExF,GAAG,CAAC;EACpD,IAAIwD,GAAG,GAAG/C,OAAO,CAAC/C,EAAE,CAACgJ,YAAY,CAAC,CAAC;EACnC,QAAQlD,GAAG;IACT,KAAK,IAAI;MACP7C,KAAK,CAACwB,aAAa,CAAC,eAAe,CAAC,GAAG,IAAI;MAC3C;IACF,KAAK,IAAI;MACPxB,KAAK,CAACwB,aAAa,CAAC,eAAe,CAAC,GAAG,MAAM;MAC7C;IACF,KAAK,IAAI;MACPxB,KAAK,CAACwB,aAAa,CAAC,eAAe,CAAC,GAAG,OAAO;MAC9C;IACF,KAAK,IAAI;MACPxB,KAAK,CAACwB,aAAa,CAAC,eAAe,CAAC,GAAG,MAAM;MAC7C;EACJ;EACA,MAAM;IAAEkK,aAAa;IAAE1I,SAAS,EAAE2I;EAAM,CAAC,GAAGxN,SAAS,CAAC,CAAC;EACvD,IAAIyN,cAAc;EAClB,IAAIF,aAAa,KAAK,SAAS,EAAE;IAC/BE,cAAc,GAAG1O,MAAM,CAAC,IAAI,GAAGwD,EAAE,CAAC;EACpC;EACA,MAAMd,IAAI,GAAG8L,aAAa,KAAK,SAAS,GAAGxO,MAAM,CAAC0O,cAAc,CAAC1L,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC2L,eAAe,CAACC,IAAI,CAAC,GAAG5O,MAAM,CAAC,MAAM,CAAC;EAClH,MAAM2C,GAAG,GAAG6L,aAAa,KAAK,SAAS,GAAGE,cAAc,CAAC1L,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC2L,eAAe,GAAGE,QAAQ;EAC9F,MAAM9L,GAAG,GAAGL,IAAI,CAAC1C,MAAM,CAAC,QAAQwD,EAAE,IAAI,CAAC;EACvC,MAAMsL,OAAO,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,CAAC;EAC5C1O,aAAa,CAAC2C,GAAG,EAAE+L,OAAO,EAAElM,OAAO,CAAC6B,IAAI,EAAEjB,EAAE,CAAC;EAC7C,MAAMhB,IAAI,GAAGI,OAAO,CAAC/C,EAAE,CAACkP,WAAW,CAAC,CAAC;EACrC,IAAIC,IAAI;EACR,MAAMC,SAAS,GAAGrM,OAAO,CAAC/C,EAAE,CAACiM,YAAY,CAAC,CAAC;EAC3C/K,GAAG,CAAC4G,IAAI,CAAC,cAAc,EAAEsH,SAAS,CAAC;EACnC,KAAK,IAAIC,CAAC,GAAGD,SAAS,CAACrL,MAAM,GAAG,CAAC,EAAEsL,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC9CF,IAAI,GAAGC,SAAS,CAACC,CAAC,CAAC;IACnBtM,OAAO,CAAC/C,EAAE,CAACsP,SAAS,CAClBH,IAAI,CAACxL,EAAE,EACP;MAAES,IAAI,EAAE+K,IAAI,CAACI,KAAK;MAAE3K,IAAI,EAAEuK,IAAI,CAACjK;IAAU,CAAC,EAC1C,OAAO,EACP,KAAK,CAAC,EACNiK,IAAI,CAACrL,OAAO,EACZqL,IAAI,CAACrJ,GACP,CAAC;EACH;EACA,MAAM0J,WAAW,GAAGtM,GAAG,CAACE,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC;EAC9D,MAAML,cAAc,GAAG6I,YAAY,CAAC9I,OAAO,CAAC/C,EAAE,CAAC;EAC/CiD,KAAK,GAAG,MAAMP,WAAW,CAACC,IAAI,EAAEgB,EAAE,EAAEd,IAAI,EAAEC,GAAG,EAAEC,OAAO,EAAEC,cAAc,EAAEC,KAAK,CAAC;EAC9E,MAAM6J,OAAO,GAAG5J,GAAG,CAACE,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,gBAAgB,CAAC;EAC/D,MAAMwF,KAAK,GAAG9F,OAAO,CAAC/C,EAAE,CAACyP,QAAQ,CAAC,CAAC;EACnCxM,KAAK,GAAG2F,QAAQ,CAACC,KAAK,EAAE9F,OAAO,EAAEE,KAAK,EAAEC,GAAG,CAAC;EAC5C,MAAMC,KAAK,GAAGI,MAAM,CAACD,IAAI,CAACb,MAAM,CAAC;EACjCU,KAAK,CAACiG,OAAO,CAAEsG,MAAM,IAAK;IACxB,MAAM5K,IAAI,GAAGrC,MAAM,CAACiN,MAAM,CAAC;IAC3B,IAAI,CAAC5K,IAAI,CAAC8B,MAAM,EAAE;MAChB3D,KAAK,CAAC+K,QAAQ,CAACrD,IAAI,CAAC7F,IAAI,CAAC;IAC3B;IACA,IAAI9B,cAAc,CAAC+I,YAAY,CAAC2D,MAAM,CAAC,KAAK,KAAK,CAAC,EAAE;MAClD5K,IAAI,CAACgG,MAAM,GAAG,CACZ;QACE1G,IAAI,EAAEU,IAAI,CAACG,SAAS;QACpBR,aAAa,EAAE;UACb,sBAAsB,EAAE;QAC1B,CAAC;QACDH,KAAK,EAAEQ,IAAI,CAACT,SAAS,CAACC,KAAK;QAC3BC,MAAM,EAAEO,IAAI,CAACT,SAAS,CAACE;QACvB;QACA;MACF,CAAC,CACF;MACD,OAAOO,IAAI,CAACyH,CAAC;MACb,OAAOzH,IAAI,CAAC0H,CAAC;MACb,OAAO1H,IAAI,CAACR,KAAK;MACjB,OAAOQ,IAAI,CAACP,MAAM;IACpB;EACF,CAAC,CAAC;EACFuJ,cAAc,CAAC7K,KAAK,CAAC+K,QAAQ,EAAEhL,cAAc,CAAC;EAC9C9B,GAAG,CAAC4G,IAAI,CAAC,cAAc,EAAE6H,IAAI,CAACC,SAAS,CAAC3M,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;EACxD,MAAM4M,CAAC,GAAG,MAAMvN,GAAG,CAACwN,MAAM,CAAC7M,KAAK,CAAC;EACjC8M,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEF,CAAC,CAAC7B,QAAQ,EAAE9K,GAAG,EAAEsM,WAAW,EAAEzM,OAAO,EAAE,CAAC,CAAC;EACzD7B,GAAG,CAAC4G,IAAI,CAAC,cAAc,EAAE+H,CAAC,CAAC;EAC3B,CAACxB,EAAE,GAAGwB,CAAC,CAAChH,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGwF,EAAE,CAAC3K,GAAG,CAAEyE,IAAI,IAAK;IACjD0E,UAAU,CAACC,OAAO,EAAE3E,IAAI,EAAEA,IAAI,CAACsB,QAAQ,EAAE1G,OAAO,EAAEC,cAAc,EAAEW,EAAE,CAAC;EACvE,CAAC,CAAC;EACFrC,iBAAiB,CAAC,CAAC,CAAC,EAAE4B,GAAG,EAAE0L,KAAK,CAACoB,cAAc,EAAEpB,KAAK,CAACqB,WAAW,CAAC;EACnExB,QAAQ,CAACyB,MAAM,CAAC,CAAC;AACnB,CAAC;AACD,MAAMH,SAAS,GAAGA,CAACI,IAAI,EAAEC,IAAI,EAAErC,SAAS,EAAE7K,GAAG,EAAEmN,WAAW,EAAEtN,OAAO,EAAEuN,KAAK,KAAK;EAC7EvC,SAAS,CAAC3E,OAAO,CAAC,UAAStE,IAAI,EAAE;IAC/B,IAAIA,IAAI,EAAE;MACRrC,MAAM,CAACqC,IAAI,CAACnB,EAAE,CAAC,CAAC+I,MAAM,GAAG;QACvBC,IAAI,EAAE7H,IAAI,CAACyH,CAAC,GAAG4D,IAAI;QACnBvD,IAAI,EAAE9H,IAAI,CAAC0H,CAAC,GAAG4D,IAAI;QACnB7D,CAAC,EAAE4D,IAAI;QACP3D,CAAC,EAAE4D,IAAI;QACPE,KAAK;QACLhM,KAAK,EAAEQ,IAAI,CAACR,KAAK;QACjBC,MAAM,EAAEO,IAAI,CAACP;MACf,CAAC;MACD,IAAIO,IAAI,CAACF,IAAI,KAAK,OAAO,EAAE;QACzB,MAAM2L,UAAU,GAAGF,WAAW,CAACjN,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC;QACpEkN,UAAU,CAACnN,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,wBAAwB,GAAGiN,KAAK,GAAG,CAAC,GAAG,OAAO,CAAC,CAACjN,IAAI,CAAC,GAAG,EAAEyB,IAAI,CAACyH,CAAC,GAAG4D,IAAI,CAAC,CAAC9M,IAAI,CAAC,GAAG,EAAEyB,IAAI,CAAC0H,CAAC,GAAG4D,IAAI,CAAC,CAAC/M,IAAI,CAAC,OAAO,EAAEyB,IAAI,CAACR,KAAK,CAAC,CAACjB,IAAI,CAAC,QAAQ,EAAEyB,IAAI,CAACP,MAAM,CAAC;QAC/L,MAAM+F,KAAK,GAAGiG,UAAU,CAACnN,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC;QAC3D,MAAMmN,cAAc,GAAGpP,SAAS,CAAC,CAAC,CAAC6E,SAAS,CAACwK,UAAU,GAAG3L,IAAI,CAACT,SAAS,CAACC,KAAK,GAAG,CAAC,GAAG,CAAC;QACtFgG,KAAK,CAACjH,IAAI,CACR,WAAW,EACX,aAAayB,IAAI,CAACgG,MAAM,CAAC,CAAC,CAAC,CAACyB,CAAC,GAAG4D,IAAI,GAAGrL,IAAI,CAACyH,CAAC,GAAGiE,cAAc,KAAK1L,IAAI,CAACgG,MAAM,CAAC,CAAC,CAAC,CAAC0B,CAAC,GAAG4D,IAAI,GAAGtL,IAAI,CAAC0H,CAAC,GAAG,CAAC,GACzG,CAAC;QACDlC,KAAK,CAACxF,IAAI,CAAC,CAAC,CAAC4I,WAAW,CAAC5I,IAAI,CAACT,SAAS,CAACoC,SAAS,CAAC;QAClDvF,GAAG,CAAC4G,IAAI,CAAC,YAAY,EAAEhD,IAAI,CAACF,IAAI,EAAEE,IAAI,CAACgG,MAAM,CAAC;MAChD,CAAC,MAAM;QACL5J,GAAG,CAAC4G,IAAI,CAAC,YAAY,EAAEhD,IAAI,CAACnB,EAAE,CAAC;QAC/BmB,IAAI,CAAC6B,EAAE,CAACtD,IAAI,CACV,WAAW,EACX,aAAayB,IAAI,CAACyH,CAAC,GAAG4D,IAAI,GAAGrL,IAAI,CAACR,KAAK,GAAG,CAAC,KAAKQ,IAAI,CAAC0H,CAAC,GAAG4D,IAAI,GAAGtL,IAAI,CAACP,MAAM,GAAG,CAAC,GACjF,CAAC;MACH;IACF;EACF,CAAC,CAAC;EACFwJ,SAAS,CAAC3E,OAAO,CAAC,UAAStE,IAAI,EAAE;IAC/B,IAAIA,IAAI,IAAIA,IAAI,CAACF,IAAI,KAAK,OAAO,EAAE;MACjCmL,SAAS,CAACI,IAAI,GAAGrL,IAAI,CAACyH,CAAC,EAAE6D,IAAI,GAAGtL,IAAI,CAAC0H,CAAC,EAAE1H,IAAI,CAACkJ,QAAQ,EAAE9K,GAAG,EAAEmN,WAAW,EAAEtN,OAAO,EAAEuN,KAAK,GAAG,CAAC,CAAC;IAC9F;EACF,CAAC,CAAC;AACJ,CAAC;AACD,MAAMI,QAAQ,GAAG;EACf9E,UAAU;EACVuC;AACF,CAAC;AACD,MAAMwC,WAAW,GAAIC,OAAO,IAAK;EAC/B,IAAI7D,QAAQ,GAAG,EAAE;EACjB,KAAK,IAAIsC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1BtC,QAAQ,IAAI;AAChB,sBAAsBsC,CAAC;AACvB,gBAAgBuB,OAAO,CAAC,UAAUvB,CAAC,EAAE,CAAC;AACtC,kBAAkBuB,OAAO,CAAC,cAAcvB,CAAC,EAAE,CAAC;AAC5C;AACA,KAAK;EACH;EACA,OAAOtC,QAAQ;AACjB,CAAC;AACD,MAAM8D,SAAS,GAAID,OAAO,IAAK;AAC/B,mBAAmBA,OAAO,CAACE,UAAU;AACrC,aAAaF,OAAO,CAACG,aAAa,IAAIH,OAAO,CAACI,SAAS;AACvD;AACA;AACA,YAAYJ,OAAO,CAACK,UAAU;AAC9B;AACA;AACA,aAAaL,OAAO,CAACK,UAAU;AAC/B;AACA;AACA;AACA,YAAYL,OAAO,CAACG,aAAa,IAAIH,OAAO,CAACI,SAAS;AACtD,aAAaJ,OAAO,CAACG,aAAa,IAAIH,OAAO,CAACI,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYJ,OAAO,CAACM,OAAO;AAC3B,cAAcN,OAAO,CAACO,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYP,OAAO,CAACQ,cAAc;AAClC;AACA;AACA;AACA,cAAcR,OAAO,CAACS,SAAS;AAC/B;AACA;AACA;AACA;AACA,cAAcT,OAAO,CAACS,SAAS;AAC/B;AACA;AACA;AACA;AACA,wBAAwBT,OAAO,CAACU,mBAAmB;AACnD;AACA;AACA,0BAA0BV,OAAO,CAACU,mBAAmB;AACrD,cAAcV,OAAO,CAACU,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,YAAYV,OAAO,CAACW,UAAU;AAC9B,cAAcX,OAAO,CAACY,aAAa;AACnC;AACA;AACA;AACA;AACA,YAAYZ,OAAO,CAACK,UAAU;AAC9B;AACA;AACA;AACA,aAAaL,OAAO,CAACK,UAAU;AAC/B;AACA;AACA,aAAaL,OAAO,CAACK,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmBL,OAAO,CAACE,UAAU;AACrC;AACA,kBAAkBF,OAAO,CAACa,aAAa;AACvC,wBAAwBb,OAAO,CAACc,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYd,OAAO,CAACI,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIL,WAAW,CAACC,OAAO,CAAC;AACxB,CAAC;AACD,MAAM1M,MAAM,GAAG2M,SAAS;AACxB,MAAMc,OAAO,GAAG;EACd3R,EAAE;EACF0Q,QAAQ;EACRxQ,MAAM;EACNgE;AACF,CAAC;AACD,SACEyN,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}